<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Unity Shader 入门（二）：Shader介绍</title>
      <link href="/2019/04/29/shader-learning2/"/>
      <url>/2019/04/29/shader-learning2/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Shader？"><a href="#什么是Shader？" class="headerlink" title="什么是Shader？"></a>什么是Shader？</h2><p>Shader（着色器）：是渲染管线上的一小段程序，它负责将输入的Mesh（网格）以指定的方式和输入的贴图、颜色等组合作用然后输出。Shader开发者要做的就是根据输入，进行计算变换，产生输出。shader大体上可以分为两类：<br><a id="more"></a></p><ul><li>顶点着色器（Vertex Shader）</li><li>片元着色器（Fragment Shader）</li></ul><p>而在Unity Shader中分为三类：</p><ul><li>Surface Shaders （表面着色器）：是Unity对Vertex/Fragment Shader的一层包装，可以以极少的代码来完成不同的光照模型与不同平台下需要考虑的事情；缺点是能够实现的效果不如片段着色器来的多。</li><li>Vertex/Fragment Shaders （顶点/片断着色器）</li><li>Fixed Function Shaders （固定管线着色器）：已被淘汰</li></ul><h2 id="什么是着色语言HLSL、GLSL、Cg？"><a href="#什么是着色语言HLSL、GLSL、Cg？" class="headerlink" title="什么是着色语言HLSL、GLSL、Cg？"></a>什么是着色语言HLSL、GLSL、Cg？</h2><p>上一篇讲到了很多可编程的着色阶段（例如顶点着色器、片元着色器等等）。之所以称为可编程的着色阶段就是因为可以用一种特定的语言来编写程序，也就是着色语言（Shading language），以下几种常见的着色语言：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:left">API</th><th style="text-align:left">优点</th><th style="text-align:left">缺点</th></tr></thead><tbody><tr><td style="text-align:center">HLSL（High Level Shading Language）</td><td style="text-align:left">Direct3D</td><td style="text-align:left">因为是由微软控制的着色器编译，因此即使是使用了不同的硬件，同一个着色器编译下的结果也都一样</td><td style="text-align:left">支持HLSL的平台有限，几乎都是微软的产品（因为别的平台上没有相应的编译器）</td></tr><tr><td style="text-align:center">GLSL（OpenGL Shading Language）</td><td style="text-align:left">OpenGL</td><td style="text-align:left">因为没有提供着色编译器，而是由显卡驱动来完成着色器的编译工作，因此具有优秀的跨平台性</td><td style="text-align:left">编译的结果取决于硬件提供商（GLSL是依赖硬件而不是操作系统层次的）</td></tr><tr><td style="text-align:center">Cg（C for Graphic）</td><td style="text-align:left">/</td><td style="text-align:left">Cg语言是 OpenGL和 DirectX 的上层，会根据平台的不同编译成不同的中间语言，即 Cg 程序是运行在 OpenGL 和 DirectX 标准顶点和像素着色的基础上的，因此具有真正的跨平台性。因为NVIDIA和微软的合作使得 Cg 和 HLSL 语法非常相像</td><td style="text-align:left">可能无法发挥出 OpenGL 的最新特性</td></tr></tbody></table><h2 id="什么是ShaderLab？"><a href="#什么是ShaderLab？" class="headerlink" title="什么是ShaderLab？"></a>什么是ShaderLab？</h2><p>在Unity中，所有的Shader都是使用ShaderLab来编写的，从结构上来说，它定义了显示一个材质所需要的所有东西，而不仅仅是着色器代码，我们先来看一下ShaderLab的结构</p><p><img src="/2019/04/29/shader-learning2/1.png" alt="Figure 1"></p><p>一个shader包含多个属性（Properties)，然后是一个或多个的子着色器（SubShader)，在实际运行中，哪一个子着色器被使用是由运行的平台所决定的。每一个子着色器中包含一个或者多个的Pass。在计算着色时，平台先选择最优先可以使用的着色器，然后依次运行其中的Pass，然后得到输出的结果。最后指定一个FallBack，用来处理所有Subshader都不能运行的情况,一般FallBack的都是平台已经定义好的shader。</p><h3 id="ShaderLab和着色语言的关系"><a href="#ShaderLab和着色语言的关系" class="headerlink" title="ShaderLab和着色语言的关系"></a>ShaderLab和着色语言的关系</h3><p>对于表面着色器和顶点着色器我们可以在 ShaderLab 的 Pass 中的 CGPROGRAM 和 ENDCG 之间嵌套Cg/HLSL。或者在 GLSLPROGRAM 和 ENDGLSL 之间嵌套 GLSL。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line">    CGPROGRAM</span><br><span class="line">    <span class="hljs-comment">//一些编译指令，例如：</span></span><br><span class="line">    <span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">    <span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> fragment frag</span></span><br><span class="line">    <span class="hljs-comment">//Cg代码</span></span><br><span class="line">    ENDCG</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="ShaderLab的模板"><a href="#ShaderLab的模板" class="headerlink" title="ShaderLab的模板"></a>ShaderLab的模板</h3><p>当我们打开Unity，然后在Project面板点击右键，依次从中选择Create/Shader/…发现会有很多的可选项</p><p><img src="/2019/04/29/shader-learning2/2.png" alt="Figure 1"></p><ul><li>Standard Surface Shader：标准表面着色器，是一种基于物理的着色系统（使用了Physically Based Rendering（简称PBR）技术，即基于物理的渲染技术），以模拟现实真实的方式来模拟材质与灯光之间的关系，可以很轻易的表现出各种金属反光效果，同时此种Shader的书写逻辑也更符合人类的思维模式。</li><li>Unlit Shader：Vertex/Fragment Shader,也就是最基本的顶点片断着色器，不受光照影响的Shader，多用于特效、UI上的效果制作。</li><li>Image Effect Shader：也是顶点片断着色器，只不过是针对后处理而定制的模版，例如调色、景深、模糊等，这些基于最终整个屏幕画面而进行再处理的Shader就是后处理。</li><li>Compute Shader：Compute Shader是运行在图形显卡上的一段程序，独立于常规渲染管线之外的，它可以直接将GPU作为并行处理器加以利用，从而使GPU不仅具有3D渲染能力，还具有其他的运算能力。</li><li>Shader Variant Collection：Shader变体收集器，在上面创建的时候，你会发现Shader Variant Collection与以上四个是被隔开的，就是因为这个与它们不一样，它不是制作Shader的模版，而只是对Shader变体进行打包用的容器。</li></ul><p>注：以上的Standard Surface Shader、Unlit Shader、Image Effect Shader仅仅只是Unity为了方便我们书写而内置的几个模版，你完全可以建一个Unlit Shader，然后将其改成Surface Shader,同样也可以将一个Standard Surface Shader改成顶点片断着色器。</p><h2 id="Shader和Material的关系"><a href="#Shader和Material的关系" class="headerlink" title="Shader和Material的关系"></a>Shader和Material的关系</h2><p>由于在Unity中Shader就是运行在图形显卡上的一段包含指令的代码，所以我们需要再创建一个材质来关联它，这样才能把材质赋给场景中的物体来实现我们想要的效果。总结一下Shader与材质的关系：</p><ul><li>一个Shader可以与无数个材质关联。</li><li>一个材质同一时刻只能关联于一个Shader。（但是我们可以通过代码去动态改变材质所关联的Shader）</li><li>材质可以赋与模型，但是Shader不行。</li><li>材质就像是Shader的实例，每个材质都可以参数不一样呈现不同的效果，但是当Shader改变时，关联它的所有材质都会相应的改变。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shader、图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity Shader 入门（一）：渲染管线</title>
      <link href="/2019/04/28/shader-learning1/"/>
      <url>/2019/04/28/shader-learning1/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是渲染管线？"><a href="#什么是渲染管线？" class="headerlink" title="什么是渲染管线？"></a>什么是渲染管线？</h2><p>Shader（着色器）：是渲染管线上的一小段程序，要了解Shader首先要明白渲染管线是什么呢？</p><p>渲染管线的主要功能是在给定虚拟相机、三维物体、光源、照明模式，以及纹理等诸多<br>条件的情况下，生成或绘制一幅二维图像的过程。对于实时渲染来说，渲染管线就是基础，可以说渲染管线是实时渲染的底层工具。<br><a id="more"></a><br><img src="/2019/04/28/shader-learning1/1.png" alt="在左图中，虚拟相机放在棱椎的顶端黑点（四条线段的交汇点），右图显示的就是此时渲染的图像，只有可视体内部的图元会被渲染。"></p><p>在概念上可以将图形渲染管线分为四个阶段：</p><ul><li>应用程序阶段（The Application）</li><li>几何阶段（The Geometry）</li><li>光栅化阶段（The Rasterizer）</li><li>像素处理阶段（pixel processing）</li></ul><p><img src="/2019/04/28/shader-learning1/2.png" alt="Figure 1.2"></p><p>这里有几个要点：</p><ul><li>每个阶段本身也可能是一条管线，如图中的几何阶段所示。此外，还可以对有的阶段进行全部或者部分的并行化处理，如图中的像素处理阶段。应用程序阶段虽然是一个单独的过程，但是依然可以对之进行管线化或者并行化处理。</li><li>最慢的管线阶段决定绘制速度，即图像的更新速度，这种速度一般用 <strong>frames per second(FPS)</strong> 来表示，也就是每秒绘制的图像数量，或者用 <strong>Hertz (Hz)</strong> 来表示。</li></ul><h2 id="应用程序阶段-The-Application-Stage"><a href="#应用程序阶段-The-Application-Stage" class="headerlink" title="应用程序阶段 The Application Stage"></a>应用程序阶段 The Application Stage</h2><p>顾名思义，应用程序阶段是由应用程序驱动的，一般是图形渲染管线概念上的第一个阶段。开发者能够对该阶段发生的情况进行完全控制，可以通过改变实现方法来改变实际性能，可以做的任务包括：</p><ul><li>碰撞检测、输入检测、力反馈</li><li>纹理动画、变换仿真、几何形变</li><li>等等</li></ul><p>在其他阶段是全部或者部分建立在硬件基础上，因此要改变实现过程会非常困难。</p><p>正因应用程序阶段是软件方式实现，因此不能像几何和光栅化阶段那样继续分为若干个子阶段。但为了提高性能，该阶段还是可以在几个并行处理器上同时执行。在 CPU 设计上，称这种形式为超标量体系（superscalar）结构，因为它可以在同一阶段同一时间做不同的几件事情。</p><p>应用程序阶段通常完成一些不在其他阶段执行的计算，如层次视锥裁剪等加速算法就可以在这里实现。</p><p>应用程序阶段的主要任务：在应用程序阶段的末端，将需要在屏幕上（具体形式取决于具体输入设备）显示出来绘制的几何体（也就是绘制图元(rendering primitives)：如点、线、矩形等）、以及摄像机位置输入到绘制管线的下一个阶段————几何阶段。</p><h2 id="几何阶段-The-Geometry-Stage"><a href="#几何阶段-The-Geometry-Stage" class="headerlink" title="几何阶段 The Geometry Stage"></a>几何阶段 The Geometry Stage</h2><p>这个阶段用于处理几乎所有我们要绘制的几何相关的事情，比如决定画什么、怎么画、画在哪里等等（这一段主要在GPU上进行），因为事情太多，因此可以进一步细分成一个小的流水线：</p><ul><li>顶点着色 Vertex Shading</li><li>投影 Projection</li><li>裁剪 Clipping</li><li>屏幕映射 Screen Mapping</li></ul><p><img src="/2019/04/28/shader-learning1/3.png" alt="Figure 3.1"></p><h3 id="顶点着色-Vertex-Shading"><a href="#顶点着色-Vertex-Shading" class="headerlink" title="顶点着色 Vertex Shading"></a>顶点着色 Vertex Shading</h3><p>顶点着色 Vertex Shading 阶段主要的任务是：</p><ul><li>计算顶点的位置</li><li>计算程序员要的顶点的输出数据例如：法线、纹理贴图坐标等等</li></ul><p>一般来说, 模型大部分的着色是通过：计算光源作用于每个顶点的位置、法线信息的结果，存储时仅存储顶点处的颜色，然后在三角形上插值这些颜色来得到的。顶点着色器现在是一个更通用的部分, 专门用于设置与每个顶点关联的数据比如可以用于顶点绑定、图像变换等等。</p><p>在绘制到屏幕上之前，模型通常需要变换到若干不同的空间或坐标系中。模型变换的变换对象一般是模型的顶点和法线。物体的坐标称为模型坐标。世界空间是唯一的，所有的模型经过变换后都位于同一个空间中。</p><p>就像上文提到，应该仅对相机（或者视点）可以看到的模型进行绘制，而相机在世界空间中有一个位置和一个方向。为了方便投影和裁剪，必须对相机和所有的模型进行视点变换。变换的目的就是要把相机放在原点，然后进行视点校准，使其朝向 Z 轴负方向，y 轴指向上方,x 轴指向右边。在视点变换后，实际位置和方向就依赖于当前的 API。我们称上述空间为相机空间或者观察空间，下图显示了视点变换对相机和模型的影响。</p><p><img src="/2019/04/28/shader-learning1/4.png" alt="Figure 3.2 在左图中，摄像机根据用户指定的位置进行放置和定位。在右图中，视点变换从原点沿着 Z 轴负方向对相机重新定位，这样可以使裁剪和投影操作更简单、更快速。可视范围是一个平截椎体，因此可以认为它是透视模式。"></p><p>为了产生逼真的场景，仅仅渲染形状和位置是远远不够的，我们需要对物体的外观进行建模。而物体经过建模，会得到对包括每个对象的材质，以及照射在对象上的任何光源的效果在内的一些刻画。且光照和材质可以用任意数量的方式，从简单的颜色描述到复杂的物理描述来模拟。</p><p>确定材质上的光照效果的这种操作被称为着色（shading），着色过程涉及在对象上的各个点处计算着色方程（shading equation）。通常，这些计算中的一些在几何阶段期间在模型的顶点上执行（vertex shading），而其他计算可以在每像素光栅化（per-pixel rasterization）期间执行。可以在每个顶点处存储各种材料数据，诸如点的位置，法线，颜色或计算着色方程所需的任何其它数字信息。顶点着色的结果（其可以是颜色，向量，纹理坐标或任何其他种类的着色数据）计算完成后，会被发送到光栅化阶段以进行插值操作。</p><p>着色计算通常认为是在世界空间中进行的。在实践中，有时需要将相关实体（诸如相机和光源）转换到一些其它空间（诸如模型或观察空间）并在那里执行计算，也可以得到正确的结果。这是因为如果着色过程中所有的实体变换到了相同的空间，着色计算中需要的诸如光源，相机和模型之间的相对关系是不会变的。</p><h3 id="投影-Projection"><a href="#投影-Projection" class="headerlink" title="投影 Projection"></a>投影 Projection</h3><p>在光照处理之后，渲染系统就开始进行投影操作，即将视体变换到一个对角顶点分别是 (-1,-1,-1) 和 (1,1,1) 单位立方体（unit cube）内，这个单位立方体通常也被称为规范视域体（Canonical View Volume，CVV）。目前，主要有两种投影方法，即：</p><ul><li>正交投影（orthographic projection，或称 parallel projection）：正交投影的可视体通常是一个矩形，正交投影可以把这个视体变换为单位立方体。正交投影的主要特性是平行线在变换之后彼此之间仍然保持平行，这种变换是平移与缩放的组合。</li><li>透视投影（perspective projection）：相比之下，透视投影比正交投影复杂一些。在这种投影中，越远离摄像机的物体，它在投影后看起来越小。更进一步来说，平行线将在地平线处会聚。透视投影的变换其实就是模拟人类感知物体的方式。</li></ul><p><img src="/2019/04/28/shader-learning1/5.png" alt="Figure 3.3 左边为正交投影，右边为透视投影"></p><p>正交投影和透视投影都可以通过 4 x 4 的矩阵来实现，在任何一种变换之后，都可以认为模型位于归一化处理之后的设备坐标系中。虽然这些矩阵变换是从一个可视体变换到另一个，但它们仍被称为投影，因为在完成显示后，Z 坐标将不会再保存于的得到的投影图片中。通过这样的投影方法，就<strong>将模型从三维空间投影到了二维的空间中</strong>。</p><h3 id="可选择的顶点处理"><a href="#可选择的顶点处理" class="headerlink" title="可选择的顶点处理"></a>可选择的顶点处理</h3><p>这一部分是这个流水线上的可选项，不一定必须经历这个环节，是否启用取决于硬件的条件，这些环节彼此之间是相互独立的，按照顺序是：</p><ul><li>曲面细分 tessellation：例如我们用三角形来描绘物体，理论上将三角形划分的越细物体也就越精细，如果这个物体离摄像头很远或者只在摄像头内出现一角，花费大量的三角形细分就比较浪费资源了。但在应用曲面细分，曲面就可以用适当的三角形数来生成。</li><li>几何元着色 geometry shading：这个阶段的作用和曲面细分类似，都可以生成新的顶点，但这是一个输出与输入的图元都受限的阶段，相应的也较为简单快速。最广泛应用这个阶段的地方可能是 <strong>生成粒子</strong> 例如烟火效果，每一点火星就好像一个点，几何元着色可以将这个点由一个面对观众的正方形（两个三角形组成）来表示，这更方便我们渲染图元。</li><li>流式输出 stream output：这个阶段让我将GPU当作几何引擎，这个阶段我们不是把数据传给剩余的流水线去处理，而是可以选择将它们输出到数组以进行进一步处理，这些数据可以给CPU，或者GPU自己，这个阶段在经常用于生成粒子，例如上面烟火的例子。</li></ul><h3 id="裁剪-Clipping"><a href="#裁剪-Clipping" class="headerlink" title="裁剪 Clipping"></a>裁剪 Clipping</h3><p>只有当图元完全或部分存在于视体（也就是上文的规范视域体CVV）内部的时候，才需要将其发送到光栅化阶段，这个阶段可以把这些图元在屏幕上绘制出来。显然一个图元相对视体内部的位置，分为三种情况：完全位于内部、完全位于外部、部分位于内部。所以就要分情况进行处理：</p><ul><li>当图元完全位于视体内部：那么它可以直接进行下一个阶段。</li><li>当图元完全位于视体外部：不会进入下一个阶段，可直接丢弃，因为它们无需进行渲染。</li><li>当图元部分位于视体内部：则需要对那些部分位于视体内的图元进行裁剪处理。对部分位于视体内部的图元进行裁剪操作，这就是裁剪过程存在的意义。裁剪过程见下图。</li></ul><p><img src="/2019/04/28/shader-learning1/6.png" alt="Figure 3.4 投影变换后，只对单位立方体内的图元继续进行处理，同时沿着单位立方体将与单位立方体相交的图元裁剪掉，因此会产生新的图元，同时舍弃旧的图元。"></p><h3 id="屏幕映射-Screen-Mapping"><a href="#屏幕映射-Screen-Mapping" class="headerlink" title="屏幕映射 Screen Mapping"></a>屏幕映射 Screen Mapping</h3><p>只有在视体内部经过裁剪的图元，以及之前完全位于视体内部的图元，才可以进入到屏幕映射阶段。进入到这个阶段时，坐标仍然是三维的（但显示状态在经过投影阶段后已经成了二维），每个图元的 x 和 y 坐标变换到了屏幕坐标系中，屏幕坐标系连同 z 坐标一起称为窗口坐标系。假定在一个窗口里对场景进行绘制，窗口的最小坐标为（x1，y1），最大坐标为（x2，y2），其中 x1 &lt; x2，y1 &lt; y2。屏幕映射首先进行平移，随后进行缩放，在映射过程中 z 坐标不受影响。新的 x 和 y 坐标称为屏幕坐标系，与 z 坐标一起（OpenGL下是[-1,+1]，DirectX下是[0,1]）进入光栅化阶段。如下图：</p><p><img src="/2019/04/28/shader-learning1/7.png" alt="Figure 3.5 经过投影变换，图元全部位于单位立方体之内，而屏幕映射主要目的就是找到屏幕上对应的坐标"></p><p>屏幕映射阶段的一个常见困惑是整型和浮点型的点值如何与像素坐标（或纹理坐标）进行关联。因为像素的中点可以定义在0.5处，因此索引在[0,9]之内的像素可以表示的浮点范围在[0.0,10.0)之内，这个转换可以简单的通过以下来转变：<br>$$d=floor(c)$$<br>$$c=d+0.5$$<br>其中 d 是像素的整数索引, c 是像素内的浮点值。</p><h2 id="光栅化阶段-The-Rasterizer-Stage"><a href="#光栅化阶段-The-Rasterizer-Stage" class="headerlink" title="光栅化阶段 The Rasterizer Stage"></a>光栅化阶段 The Rasterizer Stage</h2><p>给定经过变换和投影之后的顶点，颜色以及纹理坐标（均来自于几何阶段），给每个像素（Pixel）正确配色，以便正确绘制整幅图像。这个过个过程叫光珊化（rasterization）这个阶段主要分成两部分：三角形设定（Triangle Setup）也被称为图元装配和三角形遍历（Triangle Traversal），即从二维顶点所处的屏幕空间（所有顶点都包含 Z 值即深度值，及各种与相关的着色信息）到屏幕上的像素的转换。</p><p><img src="/2019/04/28/shader-learning1/8.png" alt="Figure 4 光栅化阶段一般细分为三角形设定和三角形遍历两个子阶段。"></p><h3 id="三角形设定-Triangle-Setup"><a href="#三角形设定-Triangle-Setup" class="headerlink" title="三角形设定 Triangle Setup"></a>三角形设定 Triangle Setup</h3><p>三角形设定阶段主要用来计算三角形表面差异和边缘方程等其他相关数据。该数据主要用于扫描转换（scan conversion），以及由几何阶段处理的各种着色数据的插值操作所用，该过程在专门为其设计的硬件上执行。</p><h3 id="三角形遍历-Triangle-Traversal"><a href="#三角形遍历-Triangle-Traversal" class="headerlink" title="三角形遍历 Triangle Traversal"></a>三角形遍历 Triangle Traversal</h3><p>在三角形遍历阶段将进行逐像素检查操作，检查该像素处的像素中心是否由三角形覆盖，而对于有三角形部分重合的像素，将在其重合部分生成片段（fragment）。找到哪些采样点或像素在三角形中的过程通常叫三角形遍历（TriangleTraversal）或扫描转换（scan conversion）。每个三角形片段的属性均由三个三角形顶点的数据插值而生成。这些属性包括片段的深度，以及来自几何阶段的着色数据。</p><h2 id="像素处理-Pixel-Processing"><a href="#像素处理-Pixel-Processing" class="headerlink" title="像素处理 Pixel Processing"></a>像素处理 Pixel Processing</h2><p>在这个阶段，所有的像素已经都在一个三角形中或者是前面一系列处理之后的图元下，像素处理阶段被分为像素着色和融合两个子阶段</p><p><img src="/2019/04/28/shader-learning1/9.png" alt="Figure 5 像素处理阶段一般细分为像素着色和融合两个子阶段。"></p><h3 id="像素着色-Pixel-Shading"><a href="#像素着色-Pixel-Shading" class="headerlink" title="像素着色 Pixel Shading"></a>像素着色 Pixel Shading</h3><p>所有逐像素的着色计算都在像素着色阶段进行，使用插值得来的着色数据作为输入，输出结果为一种或多种将被传送到下一阶段的颜色信息。纹理贴图操作就是在这阶段进行的。像素着色阶段是在可编程 GPU 内执行的，在这一阶段有大量的技术可以使用，其中最常见，最重要的技术之一就是纹理贴图（Texturing）。纹理贴图在书的第六章会详细讲到。简单来说，纹理贴图就是将指定图片“贴”到指定物体上的过程。而指定的图片可以是一维，二维，或者三维的，其中，自然是二维图片最为常见。如下图所示：</p><p><img src="/2019/04/28/shader-learning1/10.png" alt="Figure 6 左上角为一没有纹理贴图的飞龙模型。左下角为一贴上图像纹理的飞龙。右图为所用的纹理贴图。"></p><h3 id="融合-Merging"><a href="#融合-Merging" class="headerlink" title="融合 Merging"></a>融合 Merging</h3><p>每个像素的信息都储存在颜色缓冲器中，而颜色缓冲器是一个颜色的矩阵列（每种颜色包含红、绿、蓝三个分量）。融合阶段的主要任务是合成当前储存于缓冲器中的由之前的像素着<br>色阶段产生的片段颜色。不像其它着色阶段，通常运行该阶段的 GPU 子单元并非完全可编程的，但其高度可配置，可支持多种特效。</p><p>这个阶段还负责可见性问题的处理。这意味着当绘制完整场景的时候，颜色缓冲器中应该还包含从相机视点处可以观察到的场景图元。对于大多数图形硬件来说，这个过程是通过 Z 缓冲（也称深度缓冲器）算法来实现的。Z 缓冲算法非常简单，具有 $O(n)$ 复杂度（n 是需要绘制的像素数量），只要对每个图元计算出相应的像素 z 值，就可以使用这种方法，大概内容是：</p><ul><li>Z 缓冲器和颜色缓冲器形状大小一样，每个像素都存储着一个 z 值，这个 z 值是从相机到最近图元之间的距离。</li><li>每次将一个图元绘制为相应像素时，需要计算像素位置处图元的 z 值，并与同一像素处的 z 缓冲器内容进行比较。</li><li>如果新计算出的 z 值，远远小于 Z 缓冲器中的 z 值，那么说明即将绘制的图元与相机的距离比原来距离相机最近的图元还要近。这样像素的 z 值和颜色就由当前图元对应的值和颜色进行更新。反之，若计算出的 z 值远远大于 z 缓冲器中的 z 值，那么 z 缓冲器和颜色缓冲器中的值就无需改变。</li><li>值得注意的是这个算法不能用于渲染半透明物体，原因我们会在往后的文章解释</li></ul><p>颜色缓冲器用来存储颜色，z 缓冲器用来存储每个像素的 z 值，还有其他缓冲器可以用来过滤和捕获片段信息。</p><ul><li>比如 alpha 通道（alpha channel）和颜色缓冲器联系在一起可以存储一个与每个像素相关的不透明值。可选的 alpha 测试可在深度测试执行前在传入片段上运行。片段的 alpha 值与参考值作某些特定的测试（如等于，大于等），如果片断未能通过测试，它将不再进行进一步的处理。alpha 测试经常用于不影响深度缓存的全透明片段的处理。</li><li>模板缓冲器（stencil buffer）是用于记录所呈现图元位置的离屏缓存。每个像素通常与占用 8 个位。图元可使用各种方法渲染到模板缓冲器中，而缓冲器中的内容可以控制颜色缓存和 Z 缓存的渲染。举个例子，假设在模版缓冲器中绘制出了一个实心圆形，那么可以使用一系列操作符来将后续的图元仅在圆形所出现的像素处绘制，类似一个 mask 的操作。模板缓冲器是制作特效的强大工具。而在管线末端的所有这些功能都叫做光栅操作（raster operations ，ROP）或混合操作（blend operations）可以将颜色缓冲区中当前的颜色与在三角形内处理的像素的颜色混合，这样可以实现半透明或者颜色累积的效果。</li><li>帧缓冲器（frame buffer）通常包含一个系统所具有的所有缓冲器，但有时也可以认为是颜色缓冲器和 Z 缓冲器的组合。</li></ul><p>而当图元通过光栅化阶段之后，从相机视点处看到的东西就可以在荧幕上显示出来。为了避免观察者体验到对图元进行处理并发送到屏幕的过程，图形系统一般使用了双缓冲（double buffering）机制，这意味着屏幕绘制是在一个后置缓冲器（back buffer）中以离屏的方式进行的。一旦屏幕已在后置缓冲器中绘制，后置缓冲器中的内容就不断与已经在屏幕上显示过的前置缓冲器中的内容进行交换，当然，只有当不影响显示的时候才进行交换。</p>]]></content>
      
      
      <categories>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shader、图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity Shader 入门（六）：模型描边Shader</title>
      <link href="/2018/02/08/Unity%20Shader%20%E5%85%A5%E9%97%A8%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E6%A8%A1%E5%9E%8B%E6%8F%8F%E8%BE%B9Shader/"/>
      <url>/2018/02/08/Unity%20Shader%20%E5%85%A5%E9%97%A8%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E6%A8%A1%E5%9E%8B%E6%8F%8F%E8%BE%B9Shader/</url>
      
        <content type="html"><![CDATA[<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>前面几篇我们写了几个边缘发光的shader，另外一个类似功能的就是模型描边，和边缘发光不同的地方在于，描边是在原有模型的基础上，添加一圈的外框。</p><p>老规矩还是来看一下效果图：<br><a id="more"></a><br><img src="https://github.com/kurong00/blog/blob/master/thumbnail/shader6/RimLighting.PNG?raw=true" alt></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>说明一下这个Shader的具体实现：</p><h3 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a>实现原理：</h3><p>Mesh Doubling (复制网格)： </p><ol><li>需要一个单独的Pass来实现，重新绘制一个将所有表面都<font color="#D37885">沿着法线方向</font>延展模型，挤出一点点，然后将正面剪裁掉，只输出描边的颜色；</li><li>第二个Pass就是一个正常着色的Pass</li></ol><h3 id="具体解说："><a href="#具体解说：" class="headerlink" title="具体解说："></a>具体解说：</h3><p>先放一段实现的代码：<br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="hljs-string">"Custom/Rim/RimLighting"</span> &#123;</span><br><span class="line">Properties&#123;</span><br><span class="line">_MainColor(<span class="hljs-string">"Main Color"</span>, Color) = (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span><br><span class="line">_OutlineCol(<span class="hljs-string">"OutlineCol"</span>, Color) = (<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)</span><br><span class="line">_OutlineFactor(<span class="hljs-string">"OutlineFactor"</span>, Range(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)) = <span class="hljs-number">0.1</span></span><br><span class="line">_MainTex(<span class="hljs-string">"Base 2D"</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">"white"</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-comment">//描边使用两个Pass，第一个pass沿法线挤出一点，只输出描边的颜色</span></span><br><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">Cull Front</span><br><span class="line">CGPROGRAM</span><br><span class="line">#include <span class="hljs-string">"UnityCG.cginc"</span></span><br><span class="line">fixed4 _OutlineCol;</span><br><span class="line"><span class="hljs-keyword">float</span> _OutlineFactor;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">v2f</span></span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">float4 pos : SV_POSITION;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function">v2f <span class="hljs-title">vert</span><span class="hljs-params">(appdata_full v)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">v2f o;</span><br><span class="line">o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"><span class="hljs-comment">//将法线方向转换到视空间</span></span><br><span class="line">float3 vnormal = mul((float3x3)UNITY_MATRIX_IT_MV, v.normal);</span><br><span class="line"><span class="hljs-comment">//将视空间法线xy坐标转化到投影空间，只有xy需要，z深度不需要了</span></span><br><span class="line">float2 offset = TransformViewToProjection(vnormal.xy);</span><br><span class="line"><span class="hljs-comment">//在最终投影阶段输出进行偏移操作</span></span><br><span class="line">o.pos.xy += offset * _OutlineFactor;</span><br><span class="line"><span class="hljs-keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fixed4 frag(v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-comment">//这个Pass直接输出描边颜色</span></span><br><span class="line"><span class="hljs-keyword">return</span> _OutlineCol;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//使用vert函数和frag函数</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> vertex vert</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> fragment frag</span></span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//正常着色的Pass</span></span><br><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">CGPROGRAM</span><br><span class="line"><span class="hljs-comment">//引入头文件</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Lighting.cginc"</span></span></span><br><span class="line"><span class="hljs-comment">//使用vert函数和frag函数</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> vertex vert</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"><span class="hljs-comment">//定义Properties中的变量</span></span><br><span class="line">fixed4 _MainColor;</span><br><span class="line">sampler2D _MainTex;</span><br><span class="line"><span class="hljs-comment">//定义结构体：vertex shader阶段输出的内容</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">v2f</span></span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">float4 pos : SV_POSITION;</span><br><span class="line">float3 worldNormal : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">//定义顶点shader,参数直接使用appdata_base（包含position, noramal, texcoord）</span></span><br><span class="line"><span class="hljs-function">v2f <span class="hljs-title">vert</span><span class="hljs-params">(appdata_base v)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">v2f o;</span><br><span class="line">o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"><span class="hljs-comment">//通过TRANSFORM_TEX宏转化纹理坐标，主要处理了Offset和Tiling的改变</span></span><br><span class="line">o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);</span><br><span class="line"><span class="hljs-keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//定义片元shader</span></span><br><span class="line">fixed4 frag(v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-comment">//unity自身的diffuse也是带了环境光，这里我们也增加一下环境光</span></span><br><span class="line">fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * _MainColor.xyz;</span><br><span class="line"><span class="hljs-comment">//归一化法线，即使在vert归一化也不行，从vert到frag阶段有差值处理，传入的法线方向并不是vertex shader直接传出的</span></span><br><span class="line">fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line"><span class="hljs-comment">//把光照方向归一化</span></span><br><span class="line">fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line"><span class="hljs-comment">//根据半兰伯特模型计算像素的光照信息</span></span><br><span class="line">fixed3 lambert = <span class="hljs-number">0.5</span> * dot(worldNormal, worldLightDir) + <span class="hljs-number">0.5</span>;</span><br><span class="line"><span class="hljs-comment">//最终输出颜色为lambert光强*材质diffuse颜色*光颜色</span></span><br><span class="line">fixed3 diffuse = lambert * _MainColor.xyz * _LightColor0.xyz + ambient;</span><br><span class="line"><span class="hljs-comment">//进行纹理采样</span></span><br><span class="line">fixed4 color = _MainColor;</span><br><span class="line">color.rgb = color.rgb* diffuse;</span><br><span class="line"><span class="hljs-keyword">return</span> fixed4(color);</span><br><span class="line">&#125;</span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">FallBack <span class="hljs-string">"Diffuse"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>详细的实现，包含在注释之中了。</p><h3 id="包含问题"><a href="#包含问题" class="headerlink" title="包含问题"></a>包含问题</h3><p>但是这个实现方法有一个问题：<strong>线条并不连续</strong>，在平滑表面的表现尚可（球体，胶囊体等等），但是在锐利的表面上经常会出现断层（比如立方体等等）。还是利用Mesh Doubling (复制网格)的方法，但是不再简单只通过法线方向，而是：<font color="#D37885">不严格地按照表面沿着法线的方向延展, 而是在标准化的点位置和法线方向之间取一个恰当的参数来做插值</font>。</p><h2 id="更新方案"><a href="#更新方案" class="headerlink" title="更新方案"></a>更新方案</h2><p>修改描边Pass的vert函数：</p><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">v2f vert(appdata_full v)</span><br><span class="line">&#123;</span><br><span class="line">v2f o;</span><br><span class="line">o.pos = UnityObjectToClipPos ( v.vertex );</span><br><span class="line">float3 vnormal1 = normalize ( v.vertex.xyz );</span><br><span class="line"><span class="hljs-comment">//将法线方向转换到视空间</span></span><br><span class="line">float3 vnormal2 = mul((float3x3)UNITY_MATRIX_IT_MV, v.normal);</span><br><span class="line">vnormal1 = lerp ( vnormal1, vnormal2, _Factor );</span><br><span class="line">vnormal1 = mul ( ( float3x3 ) UNITY_MATRIX_IT_MV, vnormal1);</span><br><span class="line">float2 offset = TransformViewToProjection (vnormal1.xy );</span><br><span class="line">offset = normalize ( offset );</span><br><span class="line">float dist = distance ( mul ( UNITY_MATRIX_M, v.vertex ), _WorldSpaceCameraPos );</span><br><span class="line">o.pos.xy += offset *_OutlineFactor;</span><br><span class="line"><span class="hljs-keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的_Factor就是用来计算差值的参数，这个可以根据自己调节<code>lerp ( vnormal1, vnormal2, _Factor )</code></p><p>效果是：<img src="https://github.com/kurong00/blog/blob/master/thumbnail/shader6/RimLightingFix.PNG?raw=true" alt></p><p>最后上一个完整的修复过的Shader方案：</p><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="hljs-string">"Custom/Rim/RimLightingFix"</span> &#123;</span><br><span class="line">Properties&#123;</span><br><span class="line">_MainColor(<span class="hljs-string">"Main Color"</span>, Color) = (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span><br><span class="line">_OutlineCol(<span class="hljs-string">"OutlineCol"</span>, Color) = (<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)</span><br><span class="line">_OutlineFactor(<span class="hljs-string">"OutlineFactor"</span>, Range(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)) = <span class="hljs-number">0.1</span></span><br><span class="line">_MainTex(<span class="hljs-string">"Base 2D"</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">"white"</span>&#123;&#125;</span><br><span class="line">_Factor(<span class="hljs-string">"Control Factor"</span>,Range(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)) = <span class="hljs-number">0.1</span> </span><br><span class="line">&#125;</span><br><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-comment">//描边使用两个Pass，第一个pass沿法线挤出一点，只输出描边的颜色</span></span><br><span class="line">Pass&#123;</span><br><span class="line">Cull Front</span><br><span class="line">CGPROGRAM</span><br><span class="line"><span class="hljs-meta">#include "UnityCG.cginc"</span></span><br><span class="line"><span class="hljs-comment">//使用vert函数和frag函数</span></span><br><span class="line"><span class="hljs-meta">#pragma vertex vert</span></span><br><span class="line"><span class="hljs-meta">#pragma fragment frag</span></span><br><span class="line">fixed4 _OutlineCol;</span><br><span class="line">float _OutlineFactor;</span><br><span class="line">float _Factor;</span><br><span class="line">struct v2f</span><br><span class="line">&#123;</span><br><span class="line">float4 pos : <span class="hljs-type">SV_POSITION</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">v2f vert(appdata_full v)</span><br><span class="line">&#123;</span><br><span class="line">v2f o;</span><br><span class="line">o.pos = UnityObjectToClipPos ( v.vertex );</span><br><span class="line">float3 vnormal1 = normalize ( v.vertex.xyz );</span><br><span class="line"><span class="hljs-comment">//将法线方向转换到视空间</span></span><br><span class="line">float3 vnormal2 = mul((float3x3)UNITY_MATRIX_IT_MV, v.normal);</span><br><span class="line">vnormal1 = lerp ( vnormal1, vnormal2, _Factor );</span><br><span class="line">vnormal1 = mul ( ( float3x3 ) UNITY_MATRIX_IT_MV, vnormal1);</span><br><span class="line">float2 offset = TransformViewToProjection (vnormal1.xy );</span><br><span class="line">offset = normalize ( offset );</span><br><span class="line">float dist = distance ( mul ( UNITY_MATRIX_M, v.vertex ), _WorldSpaceCameraPos );</span><br><span class="line">o.pos.xy += offset *_OutlineFactor;</span><br><span class="line"><span class="hljs-keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fixed4 frag(v2f i) : <span class="hljs-type">SV_Target</span></span><br><span class="line"><span class="hljs-type"></span>&#123;</span><br><span class="line"><span class="hljs-comment">//这个Pass直接输出描边颜色</span></span><br><span class="line"><span class="hljs-keyword">return</span> _OutlineCol;</span><br><span class="line">&#125;</span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//正常着色的Pass</span></span><br><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">CGPROGRAM</span><br><span class="line"><span class="hljs-comment">//引入头文件</span></span><br><span class="line"><span class="hljs-meta">#include "Lighting.cginc"</span></span><br><span class="line"><span class="hljs-comment">//使用vert函数和frag函数</span></span><br><span class="line"><span class="hljs-meta">#pragma vertex vert</span></span><br><span class="line"><span class="hljs-meta">#pragma fragment frag</span></span><br><span class="line"><span class="hljs-comment">//定义Properties中的变量</span></span><br><span class="line">fixed4 _MainColor;</span><br><span class="line">sampler2D _MainTex;</span><br><span class="line"><span class="hljs-comment">//定义结构体：vertex shader阶段输出的内容</span></span><br><span class="line">struct v2f</span><br><span class="line">&#123;</span><br><span class="line">float4 pos : <span class="hljs-type">SV_POSITION</span>;</span><br><span class="line">float3 worldNormal : <span class="hljs-type">TEXCOORD0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">//定义顶点shader,参数直接使用appdata_base（包含position, noramal, texcoord）</span></span><br><span class="line">v2f vert(appdata_base v)</span><br><span class="line">&#123;</span><br><span class="line">v2f o;</span><br><span class="line">o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"><span class="hljs-comment">//通过TRANSFORM_TEX宏转化纹理坐标，主要处理了Offset和Tiling的改变</span></span><br><span class="line">o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);</span><br><span class="line"><span class="hljs-keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//定义片元shader</span></span><br><span class="line">fixed4 frag(v2f i) : <span class="hljs-type">SV_Target</span></span><br><span class="line"><span class="hljs-type"></span>&#123;</span><br><span class="line"><span class="hljs-comment">//unity自身的diffuse也是带了环境光，这里我们也增加一下环境光</span></span><br><span class="line">fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * _MainColor.xyz;</span><br><span class="line"><span class="hljs-comment">//归一化法线，即使在vert归一化也不行，从vert到frag阶段有差值处理，传入的法线方向并不是vertex shader直接传出的</span></span><br><span class="line">fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line"><span class="hljs-comment">//把光照方向归一化</span></span><br><span class="line">fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line"><span class="hljs-comment">//根据半兰伯特模型计算像素的光照信息</span></span><br><span class="line">fixed3 lambert = <span class="hljs-number">0.5</span> * dot(worldNormal, worldLightDir) + <span class="hljs-number">0.5</span>;</span><br><span class="line"><span class="hljs-comment">//最终输出颜色为lambert光强*材质diffuse颜色*光颜色</span></span><br><span class="line">fixed3 diffuse = lambert * _MainColor.xyz * _LightColor0.xyz + ambient;</span><br><span class="line"><span class="hljs-comment">//进行纹理采样</span></span><br><span class="line">fixed4 color = _MainColor;</span><br><span class="line">color.rgb = color.rgb* diffuse;</span><br><span class="line"><span class="hljs-keyword">return</span> fixed4(color);</span><br><span class="line">&#125;</span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">FallBack <span class="hljs-string">"Diffuse"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>描边常用于一些漫画风格的游戏场景中，能够在复杂的场景中突出被绘制的物体。</p>]]></content>
      
      
      <categories>
          
          <category> Shader </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity Shader 入门（五）：边缘发光透明版</title>
      <link href="/2017/11/25/Unity%20Shader%20%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E8%BE%B9%E7%BC%98%E5%8F%91%E5%85%89%E9%80%8F%E6%98%8E%E7%89%88/"/>
      <url>/2017/11/25/Unity%20Shader%20%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E8%BE%B9%E7%BC%98%E5%8F%91%E5%85%89%E9%80%8F%E6%98%8E%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>之前我们写过一个边缘发光的Shader（<a href="http://chenwenling.cn/2017/11/13/Unity%20Shader%20%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAShader/" target="_blank" rel="noopener">传送门</a>），这一次我们来写这个的升级版：透明物体的边缘发光。</p><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p>首先我们还是来看一下效果图：<br><img src="https://github.com/kurong00/blog/blob/master/thumbnail/shader5/RimEnerge.PNG?raw=true" alt></p><h2 id="Shader代码"><a href="#Shader代码" class="headerlink" title="Shader代码"></a>Shader代码</h2><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="hljs-string">"Custom/Rim/RimEnerge"</span> &#123;</span><br><span class="line">Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color(<span class="hljs-string">"Main Color"</span>,Color) = (<span class="hljs-number">0.6</span>,<span class="hljs-number">0.6</span>,<span class="hljs-number">0.6</span>,<span class="hljs-number">1</span>)</span><br><span class="line">        _AlphaRange(<span class="hljs-string">"Alpha Range"</span>,Range(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)) = <span class="hljs-number">0</span></span><br><span class="line">        _RimColor(<span class="hljs-string">"Rim Color"</span>,Color) = (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags&#123; </span><br><span class="line"><span class="hljs-string">"Queue"</span>=<span class="hljs-string">"Transparent"</span></span><br><span class="line"><span class="hljs-string">"IgnoreProjector"</span>=<span class="hljs-string">"True"</span></span><br><span class="line"><span class="hljs-string">"RenderType"</span>=<span class="hljs-string">"Transparent"</span> &#125;    </span><br><span class="line">ZWrite Off </span><br><span class="line">Blend SrcAlpha OneMinusSrcAlpha </span><br><span class="line">        LOD <span class="hljs-number">200</span>         </span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="hljs-meta">#pragma vertex vert</span></span><br><span class="line">            <span class="hljs-meta">#pragma fragment frag</span></span><br><span class="line"><span class="hljs-meta">#include "Lighting.cginc"      </span></span><br><span class="line"></span><br><span class="line">            struct a2v</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : <span class="hljs-type">POSITION</span>;</span><br><span class="line">                float3 normal : <span class="hljs-type">NORMAL</span>;             </span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : <span class="hljs-type">SV_POSITION</span>;</span><br><span class="line">                float3 normalDir : <span class="hljs-type">TEXCOORD0</span>;</span><br><span class="line">                float3 worldPos : <span class="hljs-type">TEXCOORD1</span>;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            float _AlphaRange;</span><br><span class="line">            fixed4 _RimColor;</span><br><span class="line"></span><br><span class="line">            v2f vert( a2v v )</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex) ;</span><br><span class="line">                o.normalDir = UnityObjectToWorldNormal(v.normal); </span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">                <span class="hljs-keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag( v2f v ):<span class="hljs-type">COLOR</span></span><br><span class="line"><span class="hljs-type">            </span>&#123;</span><br><span class="line">                float3 normal = normalize(v.normalDir);</span><br><span class="line">                float3 viewDir = normalize(_WorldSpaceCameraPos - v.worldPos);</span><br><span class="line">                float normalDotViewDir = saturate(dot(normal,viewDir));</span><br><span class="line">fixed3 diffuse = normalDotViewDir *_Color;  </span><br><span class="line">                <span class="hljs-keyword">return</span> fixed4(diffuse + _RimColor ,(<span class="hljs-number">1</span> - normalDotViewDir) * (<span class="hljs-number">1</span> - _AlphaRange) + _AlphaRange);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="hljs-string">"Diffuse"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="透明度混合"><a href="#透明度混合" class="headerlink" title="透明度混合"></a>透明度混合</h2><p>上一篇我们了解了透明度混合的原理以及一些透明度知识（<a href="http://chenwenling.cn/2017/11/18/Unity%20Shader%20%E5%85%A5%E9%97%A8%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/" target="_blank" rel="noopener">传送门</a>），而Unity中，为了进行透明度混合，我们需要用到【Blend】命令： </p><table><thead><tr><th style="text-align:center">语法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">Blend Off</td><td style="text-align:center">关闭混合（这是默认的状态）</td></tr><tr><td style="text-align:center">Blend SrcFactor DstFactor</td><td style="text-align:center">开启混合，该片元产生的颜色<em>SrcFactor. 已存在于屏幕的颜色 </em>DstFactor，然后将两者叠加在一起存入颜色缓冲。</td></tr><tr><td style="text-align:center">Blend SrcFactor DstFactor, SrcFactorA DstFactorA</td><td style="text-align:center">原理同上，不过使用了不同的混合因子</td></tr><tr><td style="text-align:center">BlendOp Op</td><td style="text-align:center">不同于上面的颜色混合，而是使用Blend Operation（<a href="https://docs.unity3d.com/Manual/SL-Blend.html" target="_blank" rel="noopener">传送门</a>）来对它们进行操作</td></tr><tr><td style="text-align:center">BlendOp OpColor, OpAlpha</td><td style="text-align:center">原理同上，不过采用不同的Blend Operation来操作Color和Alpha的通道</td></tr></tbody></table><p>混合因子：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">One</td><td style="text-align:center">因子为1，表示让源颜色或者目标颜色通过</td></tr><tr><td style="text-align:center">Zero</td><td style="text-align:center">因子为0，用来删除源颜色或者目标颜色</td></tr><tr><td style="text-align:center">SrcColor</td><td style="text-align:center">因子为源颜色</td></tr><tr><td style="text-align:center">SrcAlpha</td><td style="text-align:center">因子为源颜色的透明度</td></tr><tr><td style="text-align:center">DstColor</td><td style="text-align:center">因子为目标颜色</td></tr><tr><td style="text-align:center">DstAlpha</td><td style="text-align:center">因子为目标颜色的透明度</td></tr><tr><td style="text-align:center">OneMinusSrcColor</td><td style="text-align:center">因子为 (1 - 源颜色) 的值</td></tr><tr><td style="text-align:center">OneMinusSrcAlpha</td><td style="text-align:center">因子为 (1 - 源颜色的透明度) 的值</td></tr><tr><td style="text-align:center">OneMinusDstColor</td><td style="text-align:center">因子为 (1 - 目标颜色) 的值</td></tr><tr><td style="text-align:center">OneMinusDstAlpha</td><td style="text-align:center">因子为 (1 - 目标颜色的透明度) 的值</td></tr></tbody></table><p>此时我们再来看上面这一块代码：<br><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Tags&#123; </span><br><span class="line"><span class="hljs-string">"Queue"</span>=<span class="hljs-string">"Transparent"</span></span><br><span class="line"><span class="hljs-string">"IgnoreProjector"</span>=<span class="hljs-string">"True"</span></span><br><span class="line"><span class="hljs-string">"RenderType"</span>=<span class="hljs-string">"Transparent"</span> &#125;    </span><br><span class="line">ZWrite Off </span><br><span class="line">Blend SrcAlpha OneMinusSrcAlpha </span><br><span class="line">        LOD <span class="hljs-number">200</span></span><br></pre></td></tr></table></figure></p><ul><li><p>这里有一些新的知识：之前提过半透明物体的渲染序列要设置成<code>&quot;Queue&quot;=&quot;Transparent&quot;</code>,而<code>&quot;RenderType&quot;=&quot;Transparent&quot;</code>表示我们使用了透明度混合。通常一个半透明的Shader Tags都包含这三条：</p><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">"Queue"</span>=<span class="hljs-string">"Transparent"</span></span><br><span class="line"><span class="hljs-string">"IgnoreProjector"</span>=<span class="hljs-string">"True"</span></span><br><span class="line"><span class="hljs-string">"RenderType"</span>=<span class="hljs-string">"Transparent"</span></span><br></pre></td></tr></table></figure></li><li><p>接下来是  <code>ZWrite Off</code> : 我们在上一篇介绍过为什么透明度混合需要关闭深度写入</p></li><li>最后是  <code>Blend SrcAlpha OneMinusSrcAlpha</code> : 这里我们将源颜色的混合因子设置成<code>SrcAlpha</code>，将目标颜色的混合因子设置成 <code>OneMinusSrcAlpha</code> 以得到半透明效果。</li></ul><h2 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h2><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct a2v</span><br><span class="line">&#123;</span><br><span class="line">    float4 vertex : <span class="hljs-type">POSITION</span>;</span><br><span class="line">    float3 normal : <span class="hljs-type">NORMAL</span>;             </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct v2f</span><br><span class="line">&#123;</span><br><span class="line">    float4 pos : <span class="hljs-type">SV_POSITION</span>;</span><br><span class="line">    float3 normalDir : <span class="hljs-type">TEXCOORD0</span>;</span><br><span class="line">    float3 worldPos : <span class="hljs-type">TEXCOORD1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="a2v-：包含顶点着色器要的模型数据"><a href="#a2v-：包含顶点着色器要的模型数据" class="headerlink" title="a2v ：包含顶点着色器要的模型数据"></a>a2v ：包含顶点着色器要的模型数据</h3><ul><li><code>float4 vertex : POSITION;</code>这一句表示：用模型顶点的坐标填充vertex变量。 </li><li><code>float3 normal : NORMAL;</code> 这一句表示：用模型空间的法线方向向量填充normal变量</li></ul><h3 id="v2f-：用于顶点着色器和片元着色器之间传递信息"><a href="#v2f-：用于顶点着色器和片元着色器之间传递信息" class="headerlink" title="v2f ：用于顶点着色器和片元着色器之间传递信息"></a>v2f ：用于顶点着色器和片元着色器之间传递信息</h3><ul><li><code>float4 pos : SV_POSITION;</code>这一句表示：用裁剪空间的位置信息填充pos变量</li><li><code>float3 normalDir : TEXCOORD0;</code>这一句表示：用模型的第一套纹理坐标填充normalDir变量</li><li><code>float3 worldPos : TEXCOORD1;</code>这一句表示：用模型的第二套纹理坐标填充worldPos变量</li></ul><h2 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h2><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">v2f vert( a2v v )</span><br><span class="line">&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.normalDir = UnityObjectToWorldNormal(v.normal); </span><br><span class="line">    o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">    <span class="hljs-keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>UnityObjectToClipPos(v.vertex)</code>是Unity5.6之后的写法，之前是<code>mul(UNITY_MATRIX_MVP,v.vertex)</code> 这一句的意思是:将模型空间的顶点信息转换到裁剪空间中的位置信息，然后将信息存储在o.pos中。</li><li><code>UnityObjectToWorldNormal(v.normal)</code>这一句的意思是:法线从模型空间变换到世界空间中并计算物体在世界空间中的法线坐标。</li><li><code>mul(unity_ObjectToWorld,v.vertex).xyz;</code>这一句的意思是：将顶点从模型空间转换到世界空间的信息存储到worldPos变量中。</li></ul><h2 id="片元着色器"><a href="#片元着色器" class="headerlink" title="片元着色器"></a>片元着色器</h2><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        fixed4 frag( v2f v ):<span class="hljs-type">COLOR</span></span><br><span class="line"><span class="hljs-type">        </span>&#123;</span><br><span class="line">            float3 normal = normalize(v.normalDir);</span><br><span class="line">            float3 viewDir = normalize(_WorldSpaceCameraPos - v.worldPos);</span><br><span class="line">            float normalDotViewDir = saturate(dot(normal,viewDir));</span><br><span class="line">fixed3 diffuse = normalDotViewDir *_Color;  </span><br><span class="line">            <span class="hljs-keyword">return</span> fixed4(diffuse + _RimColor ,(<span class="hljs-number">1</span> - normalDotViewDir) * (<span class="hljs-number">1</span> - _AlphaRange) + _AlphaRange);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li><code>fixed4 frag( v2f v ):COLOR</code>  我们注意到片元着色器的后面跟着<code>:COLOR</code> ：这是Unity提供的Cg/HLSL语义。语义可以告诉shader数据的来源以及数据的输出。</li><li><code>float3 viewDir = normalize(_WorldSpaceCameraPos - v.worldPos);</code> 这里我们用<code>对象在世界坐标系中的位置</code>减去<code>摄像机的世界空间位置</code>，并进行逐顶点归一化，赋给视线的方向</li><li><code>float normalDotViewDir = saturate(dot(normal,viewDir))</code> 我们获得法线与视线的夹角</li><li><code>fixed3 diffuse = normalDotViewDir *_Color;</code> 这里我们视线与法线的夹角和主颜色相乘。</li><li><code>return fixed4(diffuse + _RimColor ,(1 - normalDotViewDir) * (1 - _AlphaRange) + _AlphaRange);</code> 最后将混合后的颜色输出。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Shader </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity Shader 入门（四）：透明效果知识储备</title>
      <link href="/2017/11/18/Unity%20Shader%20%E5%85%A5%E9%97%A8%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/"/>
      <url>/2017/11/18/Unity%20Shader%20%E5%85%A5%E9%97%A8%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>首先一个问题：如果场景中有非常多的物体，彼此之间有互相遮挡的情况，那么这些物体是按照什么样的渲染顺序进行渲染的呢？</p><h3 id="深度缓冲"><a href="#深度缓冲" class="headerlink" title="深度缓冲"></a>深度缓冲</h3><p>实际上，由于深度缓存（z-buffer）的存在,不透明的物体在不考虑渲染顺序的情况下也可以正确的被渲染。深度缓冲是用来解决物体可见性的问题，基本思想是：根据深度缓存里的值判断这个物体距离摄像机的距离。开始渲染一个片元的时候，需要把它的深度值和已存在于深度缓存中的值作比较，如果它的值距离摄像机更远那么就不会被渲染到屏幕上。否则更新片元的深度值到深度缓存中。</p><h2 id="透明效果"><a href="#透明效果" class="headerlink" title="透明效果"></a>透明效果</h2><p>我们可以不关心不透明物体的渲染顺序，因为在深度测试中就可以测试出物体离摄像机的距离再判断是否写入颜色缓冲。但是对于不透明物体，就没这么简单了。想要达到半透明的效果，我们要利用透明度混合。</p><h3 id="透明度混合"><a href="#透明度混合" class="headerlink" title="透明度混合"></a>透明度混合</h3><p>透明度混合要关闭深度写入。这是因为：假如一个半透明物体在一个不透明物体的前面，如果开启深度写入的话，距离摄像机更远的不透明物体就会被剔除，但是依照常理我们是可以透过半透明的物体看到不透明的物体。但是这就破坏了深度缓冲的机制，这是非常不好但是不得不做的折中方法，也因此使得渲染顺序变得非常重要。（注意：关闭深度写入，但是没有关闭深度测试）</p><h3 id="渲染顺序"><a href="#渲染顺序" class="headerlink" title="渲染顺序"></a>渲染顺序</h3><p>我们考虑两种情况：</p><ol><li>既有半透明物体也有不透明物体：我们先渲染所有的不透明物体再渲染半透明物体</li><li>全是半透明物体：开启深度测试，关闭深度写入的情况下将半透明物体按照距离摄像机的远近从后往前渲染。<ul><li>这里有一个小问题，深度缓冲中的值是像素级别的，而一个半透明物体很可能有非常多个像素，这么一来每一个像素的深度值都可能不一样，以此会产生<font color="#D37885"> 循环遮挡</font>的情况。</li><li>为了规避上面的问题，常常会把大的模型分割成小的几块，这样即使出现渲染错误，也不会出现太出格的结果。</li></ul></li></ol><h3 id="Unity设置的渲染序列"><a href="#Unity设置的渲染序列" class="headerlink" title="Unity设置的渲染序列"></a>Unity设置的渲染序列</h3><p>类似之前<code>Tags { &quot;RenderType&quot;=&quot;Opaque&quot; }</code>,我们可以用Queue标签来决定我们的模型是怎么渲染的。</p><table><thead><tr><th style="text-align:center">队列名称</th><th style="text-align:center">队列索引</th><th style="text-align:center">索引描述</th></tr></thead><tbody><tr><td style="text-align:center">Background</td><td style="text-align:center">1000</td><td style="text-align:center">最早被渲染的队列，一般绘制背景元素</td></tr><tr><td style="text-align:center">Geometry</td><td style="text-align:center">2000</td><td style="text-align:center">默认渲染队列，不透明物体渲染队列</td></tr><tr><td style="text-align:center">AlphaTest</td><td style="text-align:center">2450</td><td style="text-align:center">需要透明度测试的物体在这个队列渲染</td></tr><tr><td style="text-align:center">Transparent</td><td style="text-align:center">3000</td><td style="text-align:center">使用透明度混合的物体在这个队列渲染</td></tr><tr><td style="text-align:center">Overlay</td><td style="text-align:center">4000</td><td style="text-align:center">最后被渲染的物体在这个队列，一般用于叠加效果</td></tr></tbody></table><h3 id="代码设置"><a href="#代码设置" class="headerlink" title="代码设置"></a>代码设置</h3><p>如果我们想要通过透明度混合来实现半透明效果，代码如下<br><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SubShader</span><br><span class="line">   &#123;</span><br><span class="line">       Tags &#123; <span class="hljs-string">"RenderType"</span>=<span class="hljs-string">"Transparent"</span> &#125;  </span><br><span class="line">       Pass &#123; </span><br><span class="line">    ZWrite Off ······</span><br><span class="line">       &#125; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>ZWrite Off 意味者关闭深度写入，或者可以：<br><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SubShader</span><br><span class="line">   &#123;</span><br><span class="line">       Tags &#123; <span class="hljs-string">"RenderType"</span>=<span class="hljs-string">"Transparent"</span> &#125;  </span><br><span class="line">       ZWrite Off ······</span><br><span class="line">       Pass &#123; &#125; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>这样表示这个SubShader下的所有Pass都会关闭深度写入</p>]]></content>
      
      
      <categories>
          
          <category> Shader </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity Shader 入门（三）：编写第一个Shader</title>
      <link href="/2017/11/13/Unity%20Shader%20%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAShader/"/>
      <url>/2017/11/13/Unity%20Shader%20%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAShader/</url>
      
        <content type="html"><![CDATA[<h2 id="编写第一个Shader"><a href="#编写第一个Shader" class="headerlink" title="编写第一个Shader"></a>编写第一个Shader</h2><p>上一节我们学习了第一个简单的Shader，现在我们可以开始写第一个shader练练手了（搓搓手）。首先我们挑一个【边缘发光（水晶球）】的shader来写</p><p>首先来看一下效果图，如果你感兴趣的话就接下来看吧：<img src="https://github.com/kurong00/blog/blob/master/thumbnail/shader3/shader.PNG?raw=true" alt></p><h3 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a>实现原理：</h3><p>根据物体表面法向量和视线向量的夹角来判断是否是物体的边缘部位。夹角越大（接近垂直）说明越接近物体边缘部分。<font color="#D37885">重点：向量点积运算。</font></p><h3 id="具体解说："><a href="#具体解说：" class="headerlink" title="具体解说："></a>具体解说：</h3><p>先放一段实现的代码：<br><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="hljs-string">"Custom/Rim//RimBump"</span> &#123;</span><br><span class="line">Properties&#123;</span><br><span class="line">_Color(<span class="hljs-string">"Main Color"</span>, Color) = (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span><br><span class="line">_SpecColor(<span class="hljs-string">"Specular Color"</span>, Color) = (<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>)</span><br><span class="line">_BumpMap(<span class="hljs-string">"Normalmap"</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">"bump"</span> &#123;&#125;</span><br><span class="line">_RimColor(<span class="hljs-string">"Rim Color"</span>, Color) = (<span class="hljs-number">0.26</span>,<span class="hljs-number">0.19</span>,<span class="hljs-number">0.16</span>,<span class="hljs-number">0.0</span>)</span><br><span class="line">_RimPower(<span class="hljs-string">"Rim Power"</span>, Range(<span class="hljs-number">0.5</span>,<span class="hljs-number">8.0</span>)) = <span class="hljs-number">2.0</span></span><br><span class="line">&#125;</span><br><span class="line">SubShader&#123;</span><br><span class="line">Tags &#123; <span class="hljs-string">"RenderType"</span> = <span class="hljs-string">"Opaque"</span> &#125;</span><br><span class="line">LOD <span class="hljs-number">400</span></span><br><span class="line"></span><br><span class="line">CGPROGRAM</span><br><span class="line"><span class="hljs-meta">#pragma surface surf BlinnPhong</span></span><br><span class="line"><span class="hljs-meta">#pragma target 3.0</span></span><br><span class="line"></span><br><span class="line">sampler2D _BumpMap;</span><br><span class="line">fixed4 _Color;</span><br><span class="line">float4 _RimColor;</span><br><span class="line">float _RimPower;</span><br><span class="line"></span><br><span class="line">struct Input &#123;</span><br><span class="line">float2 uv_MainTex;</span><br><span class="line">float2 uv_BumpMap;</span><br><span class="line">float3 viewDir;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void surf(Input IN, inout SurfaceOutput o) &#123;</span><br><span class="line">o.Albedo = _Color.rgb;</span><br><span class="line">o.Gloss = <span class="hljs-number">1</span>;</span><br><span class="line">o.Normal = UnpackNormal(tex2D(_BumpMap, IN.uv_BumpMap));</span><br><span class="line">half rim = <span class="hljs-number">1</span> - saturate(dot(normalize(IN.viewDir), o.Normal));</span><br><span class="line">o.Emission = _RimColor.rgb * pow(rim, _RimPower);</span><br><span class="line">&#125;</span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line">FallBack <span class="hljs-string">"Diffuse"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果你看过上一篇的Shader介绍你应该可以大致看懂上面的代码，我们就关键部分说明一下：<br><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void surf(Input IN, inout SurfaceOutput o) &#123;</span><br><span class="line">o.Albedo = _Color.rgb;</span><br><span class="line">o.Gloss = <span class="hljs-number">1</span>;</span><br><span class="line">o.Normal = UnpackNormal(tex2D(_BumpMap, IN.uv_BumpMap));</span><br><span class="line">half rim = <span class="hljs-number">1</span> - saturate(dot(normalize(IN.viewDir), o.Normal));</span><br><span class="line">o.Emission = _RimColor.rgb * pow(rim, _RimPower);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>首先这两句：</li></ul><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">o.Albedo = _Color.rgb;</span><br><span class="line">o.Gloss = <span class="hljs-number">1</span>;</span><br></pre></td></tr></table></figure><p>类比上一篇，o.Albedo 此时可以获得我们设置的颜色和贴图之间混合后的颜色，o.Gloss 我们将发光强度设置成1。</p><ul><li>接下来是重点：<figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">o.Normal = UnpackNormal(tex2D(_BumpMap, IN.uv_BumpMap));</span><br><span class="line">half rim = <span class="hljs-number">1</span> - saturate(dot(normalize(IN.viewDir), o.Normal));</span><br><span class="line">o.Emission = _RimColor.rgb * pow (rim, _RimStrength);</span><br></pre></td></tr></table></figure></li></ul><p><code>UnpackNormal</code> 是定义在UnityCG.cginc文件中的方法（这个文件中包含了一系列常用的CG变量以及方法，在Unity安装路径中可以找到），<code>UnpackNormal</code>接受一个fixed4的输入，并将其转换为所对应的法线值（fixed3）。在解包得到这个值之后，将其赋给输出的Normal，接下来我们就可以来使用Normal值啦。</p><h4 id="有关法线贴图"><a href="#有关法线贴图" class="headerlink" title="有关法线贴图"></a>有关法线贴图</h4><blockquote><p>这一点归类于扩展阅读，如果你想知道<code>UnpackNormal</code>的原理可以继续查看，如果不的话就跳过这一段吧！<br>假设你想知道原理，那首先思考一个问题<strong>为什么法线贴图看起来大多是蓝色的？</strong> </p><ul><li>实际上，我们通常见到的这种偏蓝色的法线纹理中，存储的是在Tangent Space中的顶点法线方向。那么，问题又来了，什么是Tangent Space。在Tangent Space中，坐标原点就是顶点的位置，其中z轴是该顶点本身的法线方向（N）。这样，另外两个坐标轴就是和该点相切的两条切线。这样的切线是有无数条，但模型一般会给定该顶点的一个tangent。（<a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-13-normal-mapping/" target="_blank" rel="noopener">给定的过程可以见这个链接</a>）</li><li>通常我们所见的法线纹理是基于<strong>原法线信息构建的坐标系</strong>来构建出来的。那种偏蓝色的法线纹理其实就是存储在每个顶点各自的Tangent Space中<strong>法线的扰动方向</strong>。也就是说，如果一个顶点的法线方向不变，那么在它的Tangent Space中，新的normal值就是z轴方向，也就是说值为(0, 0, 1)。但这并不是法线纹理中存储的最终值：因为一个向量每个维度的取值范围在(-1, 1)，在法线贴图中被压缩在颜色的范围[0,1]中，所以需要转换：<figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 颜色 = <span class="hljs-number">0.5</span> * 法线 + <span class="hljs-number">0.5</span>;</span><br><span class="line">&gt; 线 = <span class="hljs-number">2</span> * (颜色 - <span class="hljs-number">0.5</span>);    </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><ul><li>这样，之前的法线值(0, 0, 1)实际上对应了法线纹理中RGB的值为(0.5, 0.5, 1)，而这个颜色也就是法线纹理中那大片的蓝色。这些蓝色实际上说明<strong>顶点的大部分法线是和模型本身法线一样</strong>的，不需要改变。总结一下就是，<code>法线纹理的RGB通道存储了在每个顶点各自的Tangent Space中的法线方向的映射值。</code></li><li>下一个问题：Unity编辑器中加入一张发现贴图，编辑器都会提示把法线纹理的“Texture Type”设置成“Normal Map”，这是为什么呢？是因为这样的设置可以让Unity根据不同平台对纹理进行压缩，当需要法线信息时，再通过UnpackNormal函数对法线纹理进行正确的采样，即<strong>将把颜色通道变成一个适合于实时法向映射的格式。</strong></li><li>再下一个问题：压缩的内容又是什么呢？其实法线贴图只有两个通道是真正必不可少的，因为第三个通道的值可以用另外两个推导出来（法线是单位向量）法线（x,y,z）是一条单位向量。所以知道了x,y,z里的任意两个，剩下的那个就可以通过计算得出。所以我们就可以使用2个通道的图储存x,y,z里的两个值，将xyz里剩余的值省略，通过计算得出。而压缩后的法线贴图，大小只有原来的1/4左右，故可以使用更大或者更多的贴图来提升画面品质。</li></ul></blockquote><h3 id="重点讲解"><a href="#重点讲解" class="headerlink" title="重点讲解"></a>重点讲解</h3><p>回到刚刚打断的地方，下面两句：<br><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">half rim = <span class="hljs-number">1</span> - saturate(dot(normalize(IN.viewDir), o.Normal));</span><br><span class="line">o.Emission = _RimColor.rgb * pow (rim, _RimStrength);</span><br></pre></td></tr></table></figure></p><ul><li>首先我们看<code>normalize</code>函数：为了对向量进行归一化处理（这里传入IN.viewDir指的是：WorldSpace View Direction，也就是当前坐标的视角方向）。 <code>dot</code>函数：返回传入的两个参数的点积，<code>saturate</code>函数：判断传入的参数是否在0-1之间，如果小于0，返回 0；如果大于 1，返回1； </li><li>接着第二句：<code>_RimColor.rgb * pow (rim, _RimStrength)</code>从_RimColor参数获取自发光颜色再和发光的强度混合，最终将颜色赋值给像素的Emission（发散颜色）</li><li>以上就是边缘发光效果的实现。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>下一次的shader我们将来写【半透明】的边缘发光效果。为此在下一篇我们将会梳理一下Unity shader透明效果的知识储配</p>]]></content>
      
      
      <categories>
          
          <category> Shader </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity Shader 入门（二）：查看第一个Shader</title>
      <link href="/2017/09/12/Unity%20Shader%20%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%9F%A5%E7%9C%8B%E7%AC%AC%E4%B8%80%E4%B8%AAShader/"/>
      <url>/2017/09/12/Unity%20Shader%20%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%9F%A5%E7%9C%8B%E7%AC%AC%E4%B8%80%E4%B8%AAShader/</url>
      
        <content type="html"><![CDATA[<h2 id="查看第一个shader"><a href="#查看第一个shader" class="headerlink" title="查看第一个shader"></a>查看第一个shader</h2><p>上一节是理论知识的储备，如果你对细节部分感兴趣可以阅读更多的资料（Cg，HLSL，GLSL，OpenGl，DirectX的官方Doc等等），如果不求甚解的话，那我们就通过查看第一个shader来加深理解。我们在Unity中新建一个shader（Assets-&gt;Create-&gt;shader-&gt;standard surface shader）打开看发现里面已经有很多代码了。（版本Unity 2017.2.0f3）</p><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="hljs-string">"Custom/NewSurfaceShader"</span> &#123;</span><br><span class="line">Properties &#123;</span><br><span class="line">_Color (<span class="hljs-string">"Color"</span>, Color) = (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span><br><span class="line">_MainTex (<span class="hljs-string">"Albedo (RGB)"</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">"white"</span> &#123;&#125;</span><br><span class="line">_Glossiness (<span class="hljs-string">"Smoothness"</span>, Range(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)) = <span class="hljs-number">0.5</span></span><br><span class="line">_Metallic (<span class="hljs-string">"Metallic"</span>, Range(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)) = <span class="hljs-number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line">SubShader &#123;</span><br><span class="line">Tags &#123; <span class="hljs-string">"RenderType"</span>=<span class="hljs-string">"Opaque"</span> &#125;</span><br><span class="line">LOD <span class="hljs-number">200</span></span><br><span class="line"></span><br><span class="line">CGPROGRAM</span><br><span class="line"><span class="hljs-comment">// Physically based Standard lighting model, and enable shadows on all light types</span></span><br><span class="line"><span class="hljs-meta">#pragma surface surf Standard fullforwardshadows</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Use shader model 3.0 target, to get nicer looking lighting</span></span><br><span class="line"><span class="hljs-meta">#pragma target 3.0</span></span><br><span class="line"></span><br><span class="line">sampler2D _MainTex;</span><br><span class="line"></span><br><span class="line">struct Input &#123;</span><br><span class="line">float2 uv_MainTex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">half _Glossiness;</span><br><span class="line">half _Metallic;</span><br><span class="line">fixed4 _Color;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Add instancing support for this shader. You need to check 'Enable Instancing' on materials that use the shader.</span></span><br><span class="line"><span class="hljs-comment">// See https://docs.unity3d.com/Manual/GPUInstancing.html for more information about instancing.</span></span><br><span class="line"><span class="hljs-comment">// #pragma instancing_options assumeuniformscaling</span></span><br><span class="line">UNITY_INSTANCING_CBUFFER_START(Props)</span><br><span class="line"><span class="hljs-comment">// put more per-instance properties here</span></span><br><span class="line">UNITY_INSTANCING_CBUFFER_END</span><br><span class="line"></span><br><span class="line">void surf (Input IN, inout SurfaceOutputStandard o) &#123;</span><br><span class="line"><span class="hljs-comment">// Albedo comes from a texture tinted by color</span></span><br><span class="line">fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;</span><br><span class="line">o.Albedo = c.rgb;</span><br><span class="line"><span class="hljs-comment">// Metallic and smoothness come from slider variables</span></span><br><span class="line">o.Metallic = _Metallic;</span><br><span class="line">o.Smoothness = _Glossiness;</span><br><span class="line">o.Alpha = c.a;</span><br><span class="line">&#125;</span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line">FallBack <span class="hljs-string">"Diffuse"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>emmm…….即使你有编程的基础也可能看的一头雾水，不过没关系，我们现在来一个个拆解这段代码。</p><h2 id="逐行代码查看"><a href="#逐行代码查看" class="headerlink" title="逐行代码查看"></a>逐行代码查看</h2><p>我们打开刚刚新建的shader代码，开始逐行来看吧：</p><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="hljs-string">"Custom/NewSurfaceShader"</span> &#123;</span><br><span class="line">Properties &#123;</span><br><span class="line">_Color (<span class="hljs-string">"Color"</span>, Color) = (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span><br><span class="line">_MainTex (<span class="hljs-string">"Albedo (RGB)"</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">"white"</span> &#123;&#125;</span><br><span class="line">_Glossiness (<span class="hljs-string">"Smoothness"</span>, Range(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)) = <span class="hljs-number">0.5</span></span><br><span class="line">_Metallic (<span class="hljs-string">"Metallic"</span>, Range(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)) = <span class="hljs-number">0.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="首先第一行"><a href="#首先第一行" class="headerlink" title="首先第一行"></a>首先第一行</h3><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="hljs-string">"Custom/NewSurfaceShader"</span></span><br></pre></td></tr></table></figure><p>Custom是自定义的shader默认的文件夹，如果你自己想要归类shader文件夹，就可以定义二级标题比如”Custom/MyShader/NewSurfaceShader”，这样NewSurfaceShader就归类在MyShader下啦。</p><h3 id="接着一段代码块"><a href="#接着一段代码块" class="headerlink" title="接着一段代码块"></a>接着一段代码块</h3><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Properties &#123;</span><br><span class="line">_Color (<span class="hljs-string">"Color"</span>, Color) = (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span><br><span class="line">_MainTex (<span class="hljs-string">"Albedo (RGB)"</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">"white"</span> &#123;&#125;</span><br><span class="line">_Glossiness (<span class="hljs-string">"Smoothness"</span>, Range(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)) = <span class="hljs-number">0.5</span></span><br><span class="line">_Metallic (<span class="hljs-string">"Metallic"</span>, Range(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)) = <span class="hljs-number">0.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是shader的属性部分：属性的格式写作如下<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">_Name(&quot;Display Name&quot;, type) = defaultValue[&#123;options&#125;]</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">- _Name : 变量名，在之后的Shader代码中都用这个名字来获取该属性的内容</span><br><span class="line">- Display Name : 显示名，在Unity Inspector上显示的名字</span><br><span class="line">- type : 类型，可能的type所表示的内容有以下几种：  </span><br><span class="line">- defaultValue : 上面类型的默认值</span><br><span class="line">- options : 对于2D，或者Cube贴图有关，默认写一个空白的&#123;&#125;，例如下表</span><br><span class="line"></span><br><span class="line">类型|说明|语法</span><br><span class="line">:--:|:--:|:--:|</span><br><span class="line">Float|浮点数|_MyFloat(&quot;Float&quot;,Float)=3.5</span><br><span class="line">Int|整型数|_MyInt(&quot;Int&quot;,Int)=1</span><br><span class="line">Range(min,max)|一个介于最小值和最大值之间的浮点数|_MyRange(&quot;Range&quot;,Range(0.0,1.0))=0.5</span><br><span class="line">Color|RGBA（红绿蓝和透明度）四个量来定义的颜色|_MyColor(&quot;Color&quot;,Color)=(1,1,1,1)</span><br><span class="line">2D|贴图信息|_My2D(&quot;2D&quot;,2D)=&quot;white&quot;&#123;&#125;</span><br><span class="line">Cube|立方纹理，由6张关联的2D贴图合在一起|_MyCube(&quot;Cube&quot;,Cube)=&quot;bump&quot;&#123;&#125;</span><br><span class="line">Vector|四维数|_MyVector(&quot;Vector&quot;,Vector)=(1,2,3,1)</span><br><span class="line"></span><br><span class="line">### SubShader内部构造</span><br><span class="line"></span><br><span class="line">#### Tags：键值对</span><br><span class="line">```haxe</span><br><span class="line">Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br></pre></td></tr></table></figure></p><p>tags用来告诉渲染器：何时以及怎样渲染这个对象。</p><table><thead><tr><th style="text-align:center">标签名称</th><th style="text-align:center">标签说明</th><th style="text-align:center">例子</th></tr></thead><tbody><tr><td style="text-align:center">Queue</td><td style="text-align:center">控制渲染顺序，保证不透明物体在透明物体之前渲染</td><td style="text-align:center">Tags {“Queue”=”Transparent”}</td></tr><tr><td style="text-align:center">RenderType</td><td style="text-align:center">对着色器分类，例如这是渲染透明的，这是渲染不透明的</td><td style="text-align:center">Tags {“RenderType”=”Opaque”}</td></tr><tr><td style="text-align:center">DisableBatching</td><td style="text-align:center">是否对该SubShader进行批处理</td><td style="text-align:center">Tags {“DisableBatching”=”True”}</td></tr><tr><td style="text-align:center">ForceNoShadowCasting</td><td style="text-align:center">该SubShader是否会投射阴影</td><td style="text-align:center">Tags {“ForceNoShadowCasting”=”True”}</td></tr><tr><td style="text-align:center">IgnoreProjector</td><td style="text-align:center">该SubShader是否会Project影响，常用于半透明物体</td><td style="text-align:center">Tags {“IgnoreProjector”=”True”}</td></tr><tr><td style="text-align:center">CanUseSpriteAtlas</td><td style="text-align:center">该SubShader用于Sprites时，要设置成false</td><td style="text-align:center">Tags {“CanUseSpriteAtlas”=”False”}</td></tr><tr><td style="text-align:center">PreviewType</td><td style="text-align:center">Inspector preview上默认是圆形预设，可以改为plane或者skybox</td><td style="text-align:center">Tags {“PreviewType”=”Plane”}</td></tr></tbody></table><h4 id="LOD：Level-of-Detail"><a href="#LOD：Level-of-Detail" class="headerlink" title="LOD：Level of Detail"></a>LOD：Level of Detail</h4><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOD <span class="hljs-number">200</span></span><br></pre></td></tr></table></figure><p>这个数值决定了我们能用什么样的Shader。当设定的LOD小于SubShader所指定的LOD时，这个SubShader就不可以用了。Unity自定义了一组LOD的数值，我们在实现自己的Shader的时候可以参考来设定自己的LOD数值，以便控制渲染。</p><table><thead><tr><th style="text-align:center">LOD名称</th><th style="text-align:center">数值</th></tr></thead><tbody><tr><td style="text-align:center">VertexLit及其系列</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">Decal, Reflective VertexLit</td><td style="text-align:center">150</td></tr><tr><td style="text-align:center">Diffuse</td><td style="text-align:center">200</td></tr><tr><td style="text-align:center">Diffuse Detail, Reflective Bumped Unlit, Reflective Bumped VertexLit</td><td style="text-align:center">250</td></tr><tr><td style="text-align:center">Bumped, Specular</td><td style="text-align:center">300</td></tr><tr><td style="text-align:center">Parallax</td><td style="text-align:center">500</td></tr><tr><td style="text-align:center">Parallax Specular</td><td style="text-align:center">600</td></tr></tbody></table><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">CGPROGRAM</span><br><span class="line"><span class="hljs-comment">// Physically based Standard lighting model, and enable shadows on all light types</span></span><br><span class="line"><span class="hljs-meta">#pragma surface surf Standard fullforwardshadows</span></span><br><span class="line"><span class="hljs-comment">// Use shader model 3.0 target, to get nicer looking lighting</span></span><br><span class="line"><span class="hljs-meta">#pragma target 3.0</span></span><br><span class="line">sampler2D _MainTex;</span><br><span class="line">struct Input &#123;</span><br><span class="line">float2 uv_MainTex;</span><br><span class="line">&#125;;</span><br><span class="line">half _Glossiness;</span><br><span class="line">half _Metallic;</span><br><span class="line">fixed4 _Color;</span><br><span class="line"><span class="hljs-comment">// Add instancing support for this shader. You need to check 'Enable Instancing' on materials that use the shader.</span></span><br><span class="line"><span class="hljs-comment">// See https://docs.unity3d.com/Manual/GPUInstancing.html for more information about instancing.</span></span><br><span class="line"><span class="hljs-comment">// #pragma instancing_options assumeuniformscaling</span></span><br><span class="line">UNITY_INSTANCING_CBUFFER_START(Props)</span><br><span class="line"><span class="hljs-comment">// put more per-instance properties here</span></span><br><span class="line">UNITY_INSTANCING_CBUFFER_END</span><br><span class="line">void surf (Input IN, inout SurfaceOutputStandard o) &#123;</span><br><span class="line"><span class="hljs-comment">// Albedo comes from a texture tinted by color</span></span><br><span class="line">fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;</span><br><span class="line">o.Albedo = c.rgb;</span><br><span class="line"><span class="hljs-comment">// Metallic and smoothness come from slider variables</span></span><br><span class="line">o.Metallic = _Metallic;</span><br><span class="line">o.Smoothness = _Glossiness;</span><br><span class="line">o.Alpha = c.a;</span><br><span class="line">&#125;</span><br><span class="line">ENDCG</span><br></pre></td></tr></table></figure><p>终于到了最重要的部分，首先<code>CGPROGRAM</code>和<code>ENDCG</code>成对出现,表示中间包裹的是一段Cg程序，接着是一个编译指令：<code>#pragma surface surf Standard fullforwardshadows</code><br>意味着我们要写一个表面Shader，并指定了光照模型，具体语法是<br><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#pragma surface surfaceFunction lightModel [optionalparams]</span></span><br></pre></td></tr></table></figure></p><ul><li>surface ： 声明的是一个表面着色器</li><li>surfaceFunction ： 着色器代码的方法的名字</li><li>lightModel ： 使用的光照模型。</li></ul><p>对应上面的编译指令：我们声明了一个表面着色器，实际的代码在 surf 函数中（在下面的代码能找到该函数），使用 Standard 作为光照模型。</p><p>接下来是  <code>sampler2D _MainTex;</code> 我们知道在CG中，Texture（贴图）简单来说就是一块内存存储的，使用了RGBA通道，且每个通道8bits，的数据。而具体地想知道像素与坐标的对应关系，以及获取这些数据，一次一次去计算内存地址或者偏移显然不可行，因此可以通过sampler2D来对贴图进行操作。一言以蔽之就是，sampler2D是GLSL中的2D贴图的类型，相应的，还有sampler1D，sampler3D，samplerCube等等格式。</p><p>然后的重点是：为什么在这里需要一句对_MainTex的声明？首先之前我们已经在Properties里声明过它是贴图了（<code>_MainTex (&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quot; {}</code>）。我们用来实例的这个shader其实是由两个相对独立的块组成的，外层的属性声明，回滚等等是Unity可以直接使用和编译的ShaderLab；而现在我们是在CGPROGRAM…ENDCG这样一个代码块中，这是一段CG程序。对于这段CG程序，要想访问在Properties中所定义的变量的话，必须使用<strong>和之前变量相同的名字进行声明</strong>。因此<code>sampler2D _MainTex;</code>做的事情就是再次声明并链接了_MainTex，使得接下来的CG程序能够使用这个变量。后面的<code>half _Glossiness;</code> <code>half _Metallic;</code>  <code>fixed4 _Color;</code>都是同样的道理。回到原来的地方，下一句是:<br><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct Input &#123;</span><br><span class="line">    float2 uv_MainTex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如果你有编程的经历，那么结构体应该很熟悉了，这一段我们结合下面的surf一起来说<br><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void surf (Input IN, inout SurfaceOutputStandard o) &#123;</span><br><span class="line"><span class="hljs-comment">// Albedo comes from a texture tinted by color</span></span><br><span class="line">fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;</span><br><span class="line">o.Albedo = c.rgb;</span><br><span class="line"><span class="hljs-comment">// Metallic and smoothness come from slider variables</span></span><br><span class="line">o.Metallic = _Metallic;</span><br><span class="line">o.Smoothness = _Glossiness;</span><br><span class="line">o.Alpha = c.a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>刚才提到的<code>#pragma surface surf Standard fullforwardshadows</code>里面surf 函数就是对应的上面一段。我们看函数头输入的参数有Input IN。这个Input就对应上面的结构体。我们可以把所需要参与计算的数据都放到这个Input结构中，再传入surf函数使用；SurfaceOutputStandard是已经定义好了里面类型输出结构。作为输入的结构体<strong>必须命名为Input</strong>，这个结构体中定义了一个float2的变量，emmmm···你可能会感到奇怪float后面跟着数字，这是什么意思呢？其实float和vec都可以在之后加入一个2到4的数字，来表示被打包在一起的2到4个同类型数。比如：<code>float4 color;</code> <code>float3 multipliedColor = color.rgb * coordinate.x;</code>之类的。</p><p>在这个例子里，我们声明了一个叫做<code>uv_MainTex</code>的包含两个浮点数的变量。UV mapping的作用是将一个2D贴图上的点按照一定规则映射到3D模型上，在CG程序中，我们有这样的约定，在一个贴图变量之前加上uv两个字母，就代表提取它的uv值。我们之后就可以在surf程序中直接通过访问uv_MainTex来取得这张贴图当前需要计算的点的坐标值。接下来我们详细看surf内部的操作：<br><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;</span><br></pre></td></tr></table></figure></p><p>这里用到了一个tex2d函数，这是CG程序中用来在一张贴图中对一个点进行采样的方法，返回一个float4。这个例子中用刚刚得到的float4*_Color使得这个贴图经过和颜色混合。<br><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o.Albedo = c.rgb;</span><br></pre></td></tr></table></figure></p><p>将其颜色的rbg值赋予了输出的像素颜色<br><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">o.Metallic = _Metallic;</span><br><span class="line">o.Smoothness = _Glossiness;</span><br></pre></td></tr></table></figure></p><p>都是用到上头Properties中我们定义的变量来赋值材质中的Metallic and smoothness</p><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o.Alpha = c.a;</span><br></pre></td></tr></table></figure><p>将a值赋予透明度。至此surf介绍完毕，这个例子中shader最重要的部分就是以上这些啦！</p><h3 id="最后一步"><a href="#最后一步" class="headerlink" title="最后一步"></a>最后一步</h3><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FallBack <span class="hljs-string">"Diffuse"</span></span><br></pre></td></tr></table></figure><p>当所有上面的SubShader都不可以在目标平台上运行时，Unity就会调用这个shader，当然你也可以关闭这个选项，那就意味着如果没有显卡可以跑上面的shader，那我们就不管它啦!</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这是最简单最简单的shader，看到这里的你应该可以了解一些简单的shader了，可以去Unity的Surface Shader Exampless上查看一些基础shader的编写内容，下一篇我们会开始第一个shader的编写。</p>]]></content>
      
      
      <categories>
          
          <category> Shader </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
