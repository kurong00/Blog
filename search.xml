<?xml version="1.0" encoding="utf-8"?>
<search> 
  
<<<<<<< HEAD
    
    <entry>
      <title></title>
      <link href="/2019/04/30/Unity%20Shader%20%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%90%86%E8%AE%BA%E5%87%86%E5%A4%87/"/>
      <url>/2019/04/30/Unity%20Shader%20%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%90%86%E8%AE%BA%E5%87%86%E5%A4%87/</url>
=======
  
    
    <entry>
      <title>Unity Shader 入门（四）：边缘发光效果</title>
      <link href="/2019/05/02/shader-learning4/"/>
      <url>/2019/05/02/shader-learning4/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一节我们学习查看了第一个模板Shader，现在我们开始写第一个Shader练练手。首先我们挑一个：<strong>边缘发光效果</strong> 的shader来写，先来看一下效果图：<br><a id="more"></a><br><img src="/2019/05/02/shader-learning4/rim.png" alt="Figure 1 边缘发光效果图"></p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>根据物体表面法向量和视线向量的夹角来判断是否是物体的边缘部位。夹角越大（接近垂直）说明越接近物体边缘部分，<strong>重点：向量点积运算</strong>。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>先放一段实现的代码：</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="hljs-string">"MyShader/Rim/RimBump"</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color(<span class="hljs-string">"Main Color"</span>, Color) = (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span><br><span class="line">        _SpecColor(<span class="hljs-string">"Specular Color"</span>, Color) = (<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>)</span><br><span class="line">        _BumpMap(<span class="hljs-string">"Normalmap"</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">"bump"</span> &#123;&#125;</span><br><span class="line">        _RimColor(<span class="hljs-string">"Rim Color"</span>, Color) = (<span class="hljs-number">0.26</span>,<span class="hljs-number">0.19</span>,<span class="hljs-number">0.16</span>,<span class="hljs-number">0.0</span>)</span><br><span class="line">        _RimPower(<span class="hljs-string">"Rim Power"</span>, Range(<span class="hljs-number">0.5</span>,<span class="hljs-number">8.0</span>)) = <span class="hljs-number">2.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="hljs-string">"RenderType"</span> = <span class="hljs-string">"Opaque"</span>  &#125;</span><br><span class="line">        LOD <span class="hljs-number">400</span></span><br><span class="line"></span><br><span class="line">        CGPROGRAM</span><br><span class="line">        #pragma surface surf BlinnPhong</span><br><span class="line">        #pragma target <span class="hljs-number">3.0</span></span><br><span class="line"></span><br><span class="line">        sampler2D _BumpMap;</span><br><span class="line">        fixed4 _Color;</span><br><span class="line">        float4 _RimColor;</span><br><span class="line">        <span class="hljs-keyword">float</span> _RimPower;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Input</span> &#123;</span></span><br><span class="line">        float2 uv_MainTex;</span><br><span class="line">        float2 uv_BumpMap;</span><br><span class="line">        float3 viewDir;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">surf</span><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span> </span>&#123;</span><br><span class="line">              o.Albedo = _Color.rgb;</span><br><span class="line">              o.Gloss = <span class="hljs-number">1</span>;</span><br><span class="line">              o.Normal = UnpackNormal(tex2D(_BumpMap, IN.uv_BumpMap));</span><br><span class="line">              half rim = <span class="hljs-number">1</span> - saturate(dot(normalize(IN.viewDir), o.Normal));</span><br><span class="line">              o.Emission = _RimColor.rgb * <span class="hljs-built_in">pow</span>(rim, _RimPower);</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">      &#125;</span><br><span class="line">      FallBack <span class="hljs-string">"Diffuse"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你看过上一篇的Shader介绍你应该可以大致看懂上面的代码，我们就关键部分说明一下：</p><h3 id="表面着色器"><a href="#表面着色器" class="headerlink" title="表面着色器"></a>表面着色器</h3><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">surf</span><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span> </span>&#123;</span><br><span class="line">      o.Albedo = _Color.rgb;</span><br><span class="line">      o.Gloss = <span class="hljs-number">1</span>;</span><br><span class="line">      o.Normal = UnpackNormal(tex2D(_BumpMap, IN.uv_BumpMap));</span><br><span class="line">      half rim = <span class="hljs-number">1</span> - saturate(dot(normalize(IN.viewDir), o.Normal));</span><br><span class="line">      o.Emission = _RimColor.rgb * <span class="hljs-built_in">pow</span>(rim, _RimPower);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先这两句：</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">o.Albedo = _Color.rgb;</span><br><span class="line">o.Gloss = <span class="hljs-number">1</span>;</span><br></pre></td></tr></table></figure><p>类比上一篇，o.Albedo 此时可以获得我们设置的颜色和贴图之间混合后的颜色，o.Gloss 我们将发光强度设置成1。接下来是重点：</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o.Normal = UnpackNormal(tex2D(_BumpMap, IN.uv_BumpMap));</span><br></pre></td></tr></table></figure><p>UnpackNormal：是定义在UnityCG.cginc文件中的方法（这个文件中包含了一系列常用的CG变量以及方法，在Unity安装路径中可以找到），接受一个fixed4的输入，并将其转换为所对应的法线值。在解包得到这个值之后，将其赋给输出的Normal，这里如果有疑惑的话可以跳转下面的拓展知识。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">half rim = <span class="hljs-number">1</span> - saturate(dot(normalize(IN.viewDir), o.Normal));</span><br></pre></td></tr></table></figure><ul><li>normalize 函数：为了对向量进行归一化处理（这里传入 IN.viewDir 指的是 WorldSpace View Direction，也就是当前坐标的视角方向）</li><li>dot 函数：返回传入的两个参数的点积</li><li>saturate 函数：判断传入的参数是否在 0-1 之间，如果小于0，返回 0；如果大于 1，返回1</li></ul><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o.Emission = _RimColor.rgb * <span class="hljs-built_in">pow</span> (rim, _RimStrength);</span><br></pre></td></tr></table></figure><ul><li>从 _RimColor 参数获取自发光颜色再和发光的强度混合，最终将颜色赋值给像素的Emission（发散颜色）</li></ul><h2 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h2><p>一般情况下，模型面数越高，可以表现的细节越多，效果就更加真实，相应的计算量也就增大，性能下降。为了平衡这两者的矛盾，常常就使用法线贴图来解决，法线贴图就是把法线信息储存在一张图里。使用法线贴图时，通常顶点数和三角形面数只有高精度模型的十分之一不到，因此可以通过低面数模型来模拟高面数模型的效果，增加细节层次感，效果与高模相差不多，但是大大降低了模型的面数。</p><h3 id="法线贴图的历史"><a href="#法线贴图的历史" class="headerlink" title="法线贴图的历史"></a>法线贴图的历史</h3><p>从上古时代来看，最早提出的是凹凸贴图（Bump Mapping），凹凸贴图的思想最早是由图形学届大牛中的大牛 Jim Blinn 提出，后来的 Normal Mapping，Parallax Mapping，Parallax Occulision Mapping，Relief Mapping 等等，均是基于同样的思想，只是考虑得越来越全面，效果也越来越逼真。</p><h4 id="凹凸贴图-Bump-Mapping"><a href="#凹凸贴图-Bump-Mapping" class="headerlink" title="凹凸贴图 Bump Mapping"></a>凹凸贴图 Bump Mapping</h4><p>凹凸贴图是指计算机图形学中在三维环境中通过纹理方法来产生表面凹凸不平的视觉效果。它主要的原理是通过改变表面<strong>光照方程</strong>的法线，而不是表面的几何法线，或对每个待渲染的像素在计算照明之前都要加上一个从高度图中找到的扰动，来模拟凹凸不平的视觉特征，如褶皱、波浪等等。</p><p>Blinn 于 1978 年提出了凹凸贴图方法。使用凹凸贴图，是为了给光滑的平面，在不增加顶点的情况下，增加一些凹凸的变化。他的原理是通过法向量的变化，来产生光影的变化，从而产生凹凸感，而顶点是没有变换的。表示凹凸效果的另一种方法是使用高度图来修改表面法线的方向。每个单色纹理值代表一个高度，所以在纹理中，白色表示高高度区域，黑色是低高度的区域（反之亦然）。示例如图：<br><img src="/2019/05/02/shader-learning4/2.png" alt="Figure 2 波浪高度凹凸贴图以及其在材质上的使用"></p><h4 id="移位贴图-Displacement-Mapping"><a href="#移位贴图-Displacement-Mapping" class="headerlink" title="移位贴图 Displacement Mapping"></a>移位贴图 Displacement Mapping</h4><p>移位贴图，也有人称为置换贴图，或称高度纹理贴图（Heightfield Texturing）。这种方法类似于法线贴图，移位贴图的每一个纹素中存储了一个向量，这个向量代表了对应顶点的位移。注意，此处的纹素并不是与像素一一对应，而是与顶点一一对应，因此，纹理的纹素个数与网格的顶点个数是相等的。在 VS 阶段，获取每个顶点对应的纹素中的位移向量，施加到局部坐标系下的顶点上，然后进行世界视点投影变换即可。</p><h4 id="法线贴图-Normal-Mapping"><a href="#法线贴图-Normal-Mapping" class="headerlink" title="法线贴图 Normal Mapping"></a>法线贴图 Normal Mapping</h4><p>法线贴图（Normal mapping）是凸凹贴图（Bump mapping）技术的一种应用，法线贴图有时也称为“Dot3（仿立体）凸凹纹理贴图”。凸凹与纹理贴图通常是在现有的模型法线添加扰动，不同的是，法线贴图要完全更新法线。与凸凹贴图类似的是，它也是用来在不增加多边形的情况下在浓淡效果中添加细节。但是凸凹贴图通常根据一个单独的灰度图像通道进行计算，而法线贴图的数据源图像通常是从更加细致版本的物体得到的多通道图像，即红、绿、蓝通道都是作为一个单独的颜色对待。简单来说，Normal Map 直接将正确的 Normal 值保存到一张纹理中去，那么在使用的时候直接从贴图中取即可。<br><img src="/2019/05/02/shader-learning4/3.png" alt="Figure 3 基于法线贴图的凹凸映射，每个颜色通道实际上是表面法线坐标。红色通道是 x 偏差;红色越多，正常点越多。 绿色是 y 偏差，蓝色是 z。 右边是使用法线贴图生成的图像。 请注意立方体顶部的扁平外观。"></p><h4 id="视差贴图-Parallax-Mapping"><a href="#视差贴图-Parallax-Mapping" class="headerlink" title="视差贴图 Parallax Mapping"></a>视差贴图 Parallax Mapping</h4><p>凹凸贴图和法线贴图的一个问题是，凹凸的部分永远不会随视角移动，也不会相互遮挡。如果你看一个真正的砖墙，你可能看不到砖块间的灰浆. 最好让凸起的效果实际的影响在表面的每个像素点的位置上。视差贴图 Parallax Mapping，又称为 Offset Mapping，以及 virtual displacement mapping，于2001 年由 Kaneko 引入，由 Welsh 进行了改进和推广。视差贴图是通过替换渲染多边形上的顶点处的纹理坐标来实现的，而这个替换依赖于一个关于切线空间中的视角（相对于表面法线的角度）和在该点上的高度图的方程。简单来说，Parallax Mapping 利用 Height Map 进行了近似的 Texture Offset。如图：<br><img src="/2019/05/02/shader-learning4/4.png" alt="Figure 4 视差贴图"></p><h4 id="浮雕贴图-Relief-Mapping"><a href="#浮雕贴图-Relief-Mapping" class="headerlink" title="浮雕贴图 Relief Mapping"></a>浮雕贴图 Relief Mapping</h4><p>关于浮雕贴图（Relief Mapping），有人把它誉为凹凸贴图的极致。我们知道，Parallax Mapping 是针对 Normal Mapping 的改进，利用 HeightMap 进行了近似的 Texture Offset。而Relief Mapping 是精确的 Texture Offset，所以在表现力上比较完美。<br><img src="/2019/05/02/shader-learning4/5.png" alt="Figure 5 绿色的点表示视线，紫色的点表示视线点在平面上的投影，该算法查找视线投影点（紫色的点）的垂直延长线和曲线的第一个交点"><br><img src="/2019/05/02/shader-learning4/6.png" alt="Figure 6 相较于视差贴图（左），浮雕贴图（右）可以实现更深的凹凸深度。"></p><p>parallax Mapping 能够提供比 Bump Mapping 更多的深度，尤其相比于小视角下，但是如果想提供更深的深度,Parallax Mapping 就无能为力了，Relief Mapping 则可以很好的胜任。相较于Parallax Mapping， Relief Mapping 可以实现更深的凹凸深度。浮雕贴图方法不仅更容易提供更深的深度,还可以做出自阴影和闭塞效果，当然算法也稍稍有点复杂，而如果要用一句话概括 Relief Mapping，将会是：“在 Shader 里做光线追踪”。</p><h3 id="法线贴图的存储"><a href="#法线贴图的存储" class="headerlink" title="法线贴图的存储"></a>法线贴图的存储</h3><p>历史了解一下，然后我们来看一下法线贴图是怎样存储的：我们知道法线贴图中存储的是法线的方向，也就是说是一个Vector3类型的变量，刚好和图片的 RGB 格式不谋而合。但是向量是有方向的，且贴图中只能存储的都是正数，所以还需要一个映射的过程。映射在图形学中的应用很多，比如计算半兰伯特光照时就通过把（0,1）的光照区间转化到了（0.5,1）提高了光的亮度，使效果更好。在法线贴图中，可以用0代表向量中的-1，用255代表向量中的1，不过，在shader中，贴图的颜色一般也是（0,1）区间，所以，我们在计算时只需要把从法线贴图中采样得到的法线值进行映射，将其从（0,1）区间转化到（-1,1）区间。这个步骤，Unity已经为我们完成了，我们在计算法线的时候，只需要调用 UnpackNormal 这个函数就可以实现区间的重新映射。我们在 UnityCG.cginc 中查看 UnpackNormal 的源码：</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> fixed3 <span class="hljs-title">UnpackNormalDXT5nm</span> <span class="hljs-params">(fixed4 packednormal)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    fixed3 normal;</span><br><span class="line">    normal.xy = packednormal.wy * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;</span><br><span class="line">    normal.z = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1</span> - saturate(dot(normal.xy, normal.xy)));</span><br><span class="line">    <span class="hljs-keyword">return</span> normal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)</span></span><br><span class="line"><span class="hljs-comment">// Note neutral texture like "bump" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5</span></span><br><span class="line"><span class="hljs-function">fixed3 <span class="hljs-title">UnpackNormalmapRGorAG</span><span class="hljs-params">(fixed4 packednormal)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-comment">// This do the trick</span></span><br><span class="line">   packednormal.x *= packednormal.w;</span><br><span class="line"></span><br><span class="line">    fixed3 normal;</span><br><span class="line">    normal.xy = packednormal.xy * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;</span><br><span class="line">    normal.z = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1</span> - saturate(dot(normal.xy, normal.xy)));</span><br><span class="line">    <span class="hljs-keyword">return</span> normal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">inline</span> fixed3 <span class="hljs-title">UnpackNormal</span><span class="hljs-params">(fixed4 packednormal)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(UNITY_NO_DXT5nm)</span></span><br><span class="line">    <span class="hljs-keyword">return</span> packednormal.xyz * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span></span><br><span class="line">    <span class="hljs-keyword">return</span> UnpackNormalmapRGorAG(packednormal);</span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看第一个 UnpackNormal 函数，从函数名来看为了专门解出DXT5nm格式的normal map，这种类型的normal map，只用存储法向量中的两个通道，然后解开的时候，需要计算一下，重新算出另一个向量方向。这样可以实现的原理在于，存储的向量是单位向量，长度一定的情况下，就可以通过 $sqrt(1 - x^2 - y^2)$ 来计算。其他的映射就是简单的乘2减1大法。们经常看到法线贴图是蓝紫色的，这是因为法线经常是朝着Z轴的，也就是(0,0,1)，经过上文的的公式映射后就是(0.5,0.5,1)，因此贴图偏蓝紫色。</p><p>我法线贴图中一般都存储的是切线空间，为什么不存储在世界空间或者模型空间。首先看一下世界空间，如果我们的法线贴图存储的世界空间的法线信息，我们可以直接解出法线的值，在世界空间进行计算，是最直接并且计算效率最高的做法，但是世界空间的法线贴图就跟当前环境之间耦合过大了，比如同样的两个模型，仅仅是旋转方向不同，也需要两张法线贴图，这很明显是多余的，于是就有人想出了基于模型空间的法线，基于模型空间，在计算时，把模型空间的法线转换到世界空间，虽然多了一步操作，但是同一个模型可以共用法线，不用考虑旋转等问题。但是，人们感觉模型空间的法线贴图跟模型的耦合度还是高，那就继续解耦吧，于是基于切线空间的法线贴图就诞生了。那么如何按照模型顶点的位置坐标随纹理坐标(u, v)的变化作「切线空间」呢？</p><p>$$T = (\frac{\partial x}{\partial u},\frac{\partial y}{\partial u},\frac{\partial z}{\partial u})$$<br>$$B = N \times T$$<br>$$T = (\frac{\partial x}{\partial u},\frac{\partial y}{\partial u},\frac{\partial z}{\partial u}) \times (\frac{\partial x}{\partial v},\frac{\partial y}{\partial v},\frac{\partial z}{\partial v}) $$</p><p>这就是法线贴图中存储的值。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>下一次的shader我们将来写 <strong>半透明的边缘发光</strong> 效果。为此在下一篇我们将会先梳理介绍一下Unity shader透明效果的知识。</p>]]></content>
      
      
      <categories>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shader、图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity Shader 入门（三）：查看Shader</title>
      <link href="/2019/05/01/shader-learning3/"/>
      <url>/2019/05/01/shader-learning3/</url>
      
        <content type="html"><![CDATA[<h2 id="新建Shader"><a href="#新建Shader" class="headerlink" title="新建Shader"></a>新建Shader</h2><p>首先我们新建一个Shader，这里以 Standard Surface Shader 为例，新建之后我们打开Shader文件应该会出现如下代码：<br><a id="more"></a><br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="hljs-string">"Custom/NewSurfaceShader"</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color (<span class="hljs-string">"Color"</span>, Color) = (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span><br><span class="line">        _MainTex (<span class="hljs-string">"Albedo (RGB)"</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">"white"</span> &#123;&#125;</span><br><span class="line">        _Glossiness (<span class="hljs-string">"Smoothness"</span>, Range(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)) = <span class="hljs-number">0.5</span></span><br><span class="line">        _Metallic (<span class="hljs-string">"Metallic"</span>, Range(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)) = <span class="hljs-number">0.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; <span class="hljs-string">"RenderType"</span>=<span class="hljs-string">"Opaque"</span> &#125;</span><br><span class="line">        LOD <span class="hljs-number">200</span></span><br><span class="line"></span><br><span class="line">        CGPROGRAM</span><br><span class="line">        <span class="hljs-comment">// Physically based Standard lighting model, and enable shadows on all light types</span></span><br><span class="line">        #pragma surface surf Standard fullforwardshadows</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// Use shader model 3.0 target, to get nicer looking lighting</span></span><br><span class="line">        #pragma target <span class="hljs-number">3.0</span></span><br><span class="line"></span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Input</span></span></span><br><span class="line"><span class="hljs-class">        &#123;</span></span><br><span class="line">            float2 uv_MainTex;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        half _Glossiness;</span><br><span class="line">        half _Metallic;</span><br><span class="line">        fixed4 _Color;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// Add instancing support for this shader. You need to check 'Enable Instancing' on materials that use the shader.</span></span><br><span class="line">        <span class="hljs-comment">// See https://docs.unity3d.com/Manual/GPUInstancing.html for more information about instancing.</span></span><br><span class="line">        <span class="hljs-comment">// #pragma instancing_options assumeuniformscaling</span></span><br><span class="line">        UNITY_INSTANCING_BUFFER_START(Props)</span><br><span class="line">            <span class="hljs-comment">// put more per-instance properties here</span></span><br><span class="line">        UNITY_INSTANCING_BUFFER_END(Props)</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">surf</span> <span class="hljs-params">(Input IN, inout SurfaceOutputStandard o)</span></span></span><br><span class="line"><span class="hljs-function">        </span>&#123;</span><br><span class="line">            <span class="hljs-comment">// Albedo comes from a texture tinted by color</span></span><br><span class="line">            fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;</span><br><span class="line">            o.Albedo = c.rgb;</span><br><span class="line">            <span class="hljs-comment">// Metallic and smoothness come from slider variables</span></span><br><span class="line">            o.Metallic = _Metallic;</span><br><span class="line">            o.Smoothness = _Glossiness;</span><br><span class="line">            o.Alpha = c.a;</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="hljs-string">"Diffuse"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>emmm…….即使你有编程的基础也可能看的一头雾水，不过没关系，我们现在来拆解这段代码。</p><h2 id="拆解代码"><a href="#拆解代码" class="headerlink" title="拆解代码"></a>拆解代码</h2><p>接下来我们讲逐句讲解这个Shader，弄懂每一个语句的意义。</p><h3 id="Shader名称路径"><a href="#Shader名称路径" class="headerlink" title="Shader名称路径"></a>Shader名称路径</h3><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="hljs-string">"Custom/NewSurfaceShader"</span></span><br></pre></td></tr></table></figure><p>首先这里标注了Shader的名字和路径，符号 “/“ 表示的是创建子层级，我们可以进行修改，例如这里修改为</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="hljs-string">"MyShader/FirstShader"</span></span><br></pre></td></tr></table></figure><p>我们用这个Shader新建一个材质，可以看见Shader的层级就像我们设置的这样<br><img src="/2019/05/01/shader-learning3/1.png" alt="Figure 1"><br>这里有一个注意点：如果我们把路径名称放在 Hidden下面的话，比如：</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="hljs-string">"Hidden/MyShader/FirstShader"</span></span><br></pre></td></tr></table></figure><p>则表示在材质面板中隐藏此Shader，你将无法通过材质下拉列表中找到它。这在做一些不需暴露的Shader时很有用处，可以使Shader下拉列表更精简整洁。</p><h3 id="Shader属性"><a href="#Shader属性" class="headerlink" title="Shader属性"></a>Shader属性</h3><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">    _Color (<span class="hljs-string">"Color"</span>, Color) = (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span><br><span class="line">    _MainTex (<span class="hljs-string">"Albedo (RGB)"</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">"white"</span> &#123;&#125;</span><br><span class="line">    _Glossiness (<span class="hljs-string">"Smoothness"</span>, Range(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)) = <span class="hljs-number">0.5</span></span><br><span class="line">    _Metallic (<span class="hljs-string">"Metallic"</span>, Range(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)) = <span class="hljs-number">0.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是shader的属性部分：属性的格式写作如下</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Attribute]_Name (<span class="hljs-string">"Display Name"</span>,Type) = Default Value</span><br></pre></td></tr></table></figure><ul><li>Attribute：属性标记，用于对当前这条属性进行一些特殊的处理，此标记不是必选项，可以不添加，同时一条属性上也可以有多条属性标记。</li><li>_Name：变量名，在之后的Shader代码中都用这个名字来获取该属性的内容，在名称前一定要加上下划线。</li><li>Display Name：在Unity Inspector上显示的名字，主要起到说明解释的作用。</li><li>Type：类型，可能的type所表示的内容有以下几种：  </li><li>Default Value：上面类型的默认值</li></ul><h4 id="属性分类"><a href="#属性分类" class="headerlink" title="属性分类"></a>属性分类</h4><table><thead><tr><th style="text-align:center">属性标记</th><th style="text-align:center">适用类型</th><th style="text-align:center">举例</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">HDR</td><td style="text-align:center">Color</td><td style="text-align:center">[HDR]_Color(“Color”, Color) = (1,1,0,1)</td><td style="text-align:center">当给颜色添加了HDR后，则在材质面板中的颜色上会显示HDR的字样，HDR可以使颜色亮度的值超过1，通过这个值可以配合镜头Bloom效果做出物体泛光的视觉效果。</td></tr><tr><td style="text-align:center">PowerSlider</td><td style="text-align:center">Range</td><td style="text-align:center">[PowerSlider(3)]_MyRange(“Range”,Range(0.0,1.0)) = 0.5</td><td style="text-align:center">方便用户调节滑杆，例如有个属性值是从0-1,但在大部分情况下所用到的值都是0-0.1，同时需要更精细的在这区间进行微调。一般情况下用户难以控制微调，这个时候就可以利用PowerSlider来解决此问题。</td></tr><tr><td style="text-align:center">Toggle</td><td style="text-align:center">Range</td><td style="text-align:center">[Toggle]_MyRange(“Range”,Range(0.0,1.0)) =0.5</td><td style="text-align:center">表示开关，0代表关，1代表开</td></tr><tr><td style="text-align:center">Enum</td><td style="text-align:center">Range</td><td style="text-align:center">[Enum(···)]_MyRange(“Range”,Range(0.0,1.0)) =0.5</td><td style="text-align:center">枚举，显示下拉列表</td></tr><tr><td style="text-align:center">NoScaleOffset</td><td style="text-align:center">2D</td><td style="text-align:center">[NoScaleOffset]_MainTex(“2D”, 2D) = “white” {}</td><td style="text-align:center">纹理贴图在材质面板中除了显示贴图槽以外默认还会显示两组Float。如果我们不希望用户去调节此参数，我们可以使用[NoScaleOffset]属性标记来将它们隐藏掉。</td></tr><tr><td style="text-align:center">Normal</td><td style="text-align:center">2D</td><td style="text-align:center">[Normal]_MainTex(“2D”, 2D) = “white” {}</td><td style="text-align:center">添加[Normal]，来标记此属性是用来接收法线贴图的，当用户指定了非法线的贴图时会在材质面板上进行警告提示</td></tr><tr><td style="text-align:center">Header</td><td style="text-align:center">所有</td><td style="text-align:center">[Header(I am Header)]_MyInt(“Int”,Int) = 1</td><td style="text-align:center">在材质面板上进行标注，通常用作分类组别用</td></tr><tr><td style="text-align:center">HideInInspector</td><td style="text-align:center">所有</td><td style="text-align:center">[HideInInspector]_MyInt(“Int”,Int) = 1</td><td style="text-align:center">在材质面板中隐藏此条属性，在不希望暴露某条属性时可以快速将其隐藏。</td></tr></tbody></table><h4 id="类型分类"><a href="#类型分类" class="headerlink" title="类型分类"></a>类型分类</h4><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">说明</th><th style="text-align:center">语法</th></tr></thead><tbody><tr><td style="text-align:center">Float</td><td style="text-align:center">浮点数，注意浮点数值后不需要加后缀f</td><td style="text-align:center">_MyFloat(“Float”,Float) = 3.5</td></tr><tr><td style="text-align:center">Int</td><td style="text-align:center">整型数</td><td style="text-align:center">_MyInt(“Int”,Int) = 1</td></tr><tr><td style="text-align:center">Range(min,max)</td><td style="text-align:center">一个介于最小值和最大值之间的浮点数</td><td style="text-align:center">_MyRange(“Range”,Range(0.0,1.0)) = 0.5</td></tr><tr><td style="text-align:center">Color</td><td style="text-align:center">RGBA（红绿蓝和透明度）四个量来定义的颜色</td><td style="text-align:center">_MyColor(“Color”,Color) = (1,1,1,1)</td></tr><tr><td style="text-align:center">2D</td><td style="text-align:center">贴图信息</td><td style="text-align:center">_My2D(“2D”,2D) = “white”{}</td></tr><tr><td style="text-align:center">Cube</td><td style="text-align:center">立方纹理，由6张关联的2D贴图合在一起</td><td style="text-align:center">_MyCube(“Cube”,Cube) = “bump”{}</td></tr><tr><td style="text-align:center">Vector</td><td style="text-align:center">四维数</td><td style="text-align:center">_MyVector(“Vector”,Vector) = (1,2,3,1)</td></tr></tbody></table><h3 id="Shader-Tags"><a href="#Shader-Tags" class="headerlink" title="Shader Tags"></a>Shader Tags</h3><p>Tags用来告诉渲染器：何时以及怎样渲染这个对象。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tags &#123; <span class="hljs-string">"RenderType"</span>=<span class="hljs-string">"Opaque"</span> &#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">标签名称</th><th style="text-align:center">标签说明</th><th style="text-align:center">例子</th></tr></thead><tbody><tr><td style="text-align:center">Queue</td><td style="text-align:center">控制渲染顺序，保证不透明物体在透明物体之前渲染</td><td style="text-align:center">Tags {“Queue”=”Transparent”}</td></tr><tr><td style="text-align:center">RenderType</td><td style="text-align:center">对着色器分类，例如这是渲染透明的，这是渲染不透明的</td><td style="text-align:center">Tags {“RenderType”=”Opaque”}</td></tr><tr><td style="text-align:center">DisableBatching</td><td style="text-align:center">是否对该SubShader进行批处理</td><td style="text-align:center">Tags {“DisableBatching”=”True”}</td></tr><tr><td style="text-align:center">ForceNoShadowCasting</td><td style="text-align:center">该SubShader是否会投射阴影</td><td style="text-align:center">Tags {“ForceNoShadowCasting”=”True”}</td></tr><tr><td style="text-align:center">IgnoreProjector</td><td style="text-align:center">该SubShader是否会Project影响，常用于半透明物体</td><td style="text-align:center">Tags {“IgnoreProjector”=”True”}</td></tr><tr><td style="text-align:center">CanUseSpriteAtlas</td><td style="text-align:center">该SubShader用于Sprites时，要设置成false</td><td style="text-align:center">Tags {“CanUseSpriteAtlas”=”False”}</td></tr><tr><td style="text-align:center">PreviewType</td><td style="text-align:center">Inspector preview上默认是圆形预设，可以改为plane或者skybox</td><td style="text-align:center">Tags {“PreviewType”=”Plane”}</td></tr></tbody></table><p>这里想要着重说一下的是Queue这个标签，如果你使用Unity做过一些透明和不透明物体的混合的话，很可能已经遇到过不透明物体无法呈现在透明物体之后的情况。这种情况很可能是由于Shader的渲染顺序不正确导致的。Queue指定了物体的渲染顺序，预定义的Queue有：</p><ul><li>Background - 最早被调用的渲染，用来渲染天空盒或者背景</li><li>Geometry - 这是默认值，用来渲染非透明物体（普通情况下，场景中的绝大多数物体应该是非透明的）</li><li>AlphaTest - 用来渲染经过Alpha Test的像素，单独为AlphaTest设定一个Queue是出于对效率的考虑</li><li>Transparent - 以从后往前的顺序渲染透明物体</li><li>Overlay - 用来渲染叠加的效果，是渲染的最后阶段（比如镜头光晕等特效）</li></ul><p>这些预定义的值本质上是一组定义整数，Background = 1000， Geometry = 2000, AlphaTest = 2450， Transparent = 3000，最后Overlay = 4000。在我们实际设置Queue值时，不仅能使用上面的几个预定义值，我们也可以指定自己的Queue值，写成类似这样：”Queue” = “Transparent+100”，表示一个在Transparent之后100的Queue上进行调用。通过调整Queue值，我们可以确保某些物体一定在另一些物体之前或者之后渲染，这个技巧有时候很有用处。</p><h3 id="LOD：Level-of-Detail"><a href="#LOD：Level-of-Detail" class="headerlink" title="LOD：Level of Detail"></a>LOD：Level of Detail</h3><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOD <span class="hljs-number">200</span></span><br></pre></td></tr></table></figure><p>这个数值决定了我们能用什么样的Shader。当设定的LOD小于SubShader所指定的LOD时，这个SubShader就不可以用了。Unity自定义了一组LOD的数值，我们在实现自己的Shader的时候可以参考来设定自己的LOD数值，以便控制渲染。</p><table><thead><tr><th style="text-align:center">LOD名称</th><th style="text-align:center">数值</th></tr></thead><tbody><tr><td style="text-align:center">VertexLit及其系列</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">Decal, Reflective VertexLit</td><td style="text-align:center">150</td></tr><tr><td style="text-align:center">Diffuse</td><td style="text-align:center">200</td></tr><tr><td style="text-align:center">Diffuse Detail, Reflective Bumped Unlit, Reflective Bumped VertexLit</td><td style="text-align:center">250</td></tr><tr><td style="text-align:center">Bumped, Specular</td><td style="text-align:center">300</td></tr><tr><td style="text-align:center">Parallax</td><td style="text-align:center">500</td></tr><tr><td style="text-align:center">Parallax Specular</td><td style="text-align:center">600</td></tr></tbody></table><h3 id="Shader主体代码"><a href="#Shader主体代码" class="headerlink" title="Shader主体代码"></a>Shader主体代码</h3><p>终于到了最重要的部分，首先<code>CGPROGRAM</code>和<code>ENDCG</code>成对出现，表示中间包裹的是一段Cg程序，接着是一个编译指令：</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> surface surf Standard fullforwardshadows</span></span><br></pre></td></tr></table></figure><p>意味着我们要写一个表面Shader，并指定了光照模型，具体语法是</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> surface surfaceFunction lightModel [optionalparams]</span></span><br></pre></td></tr></table></figure><ul><li>surface ： 声明的是一个表面着色器</li><li>surfaceFunction ： 着色器代码的方法的名字</li><li>lightModel ： 使用的光照模型。</li></ul><p>对应上面的编译指令：我们声明了一个表面着色器，实际的代码在 surf 函数中（在下面的Shader代码能找到该函数），使用 Standard 作为光照模型。接下来是</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sampler2D _MainTex;</span><br></pre></td></tr></table></figure><p>我们知道在CG中，Texture（贴图）简单来说就是一块内存存储的，使用了RGBA通道，且每个通道8bits的数据。而具体地想知道像素与坐标的对应关系，以及获取这些数据，一次一次去计算内存地址或者偏移显然不可行，因此可以通过sampler2D来对贴图进行操作。一言以蔽之就是，sampler2D是GLSL中的2D贴图的类型，相应的，还有sampler1D，sampler3D，samplerCube等等格式。然后的重点是：为什么在这里需要一句对_MainTex的声明？首先之前我们已经在Properties里声明过它是贴图了</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_MainTex (<span class="hljs-string">"Albedo (RGB)"</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">"white"</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>我们用来实例的这个shader其实是由两个相对独立的块组成的，外层的属性声明，回滚等等是Unity可以直接使用和编译的ShaderLab；而现在我们是在CGPROGRAM…ENDCG这样一个代码块中，这是一段Cg程序。对于这段Cg程序，要想访问在Properties中所定义的变量的话，必须使用<strong>和之前变量相同的名字进行声明</strong>。因此这样做就是再次声明并链接了_MainTex，使得接下来的Cg程序能够使用这个变量。后面的：</p><ul><li>half _Glossiness;</li><li>half _Metallic;</li><li>fixed4 _Color;</li></ul><p>都是同样的道理。回到原来的地方，下一句是:</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Input</span> &#123;</span></span><br><span class="line">    float2 uv_MainTex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="表面着色器"><a href="#表面着色器" class="headerlink" title="表面着色器"></a>表面着色器</h4><p>如果你有编程的经历，那么结构体应该很熟悉了，这一段我们结合下面的surf一起来说</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">surf</span> <span class="hljs-params">(Input IN, inout SurfaceOutputStandard o)</span></span></span><br><span class="line"><span class="hljs-function">        </span>&#123;</span><br><span class="line">            <span class="hljs-comment">// Albedo comes from a texture tinted by color</span></span><br><span class="line">            fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;</span><br><span class="line">            o.Albedo = c.rgb;</span><br><span class="line">            <span class="hljs-comment">// Metallic and smoothness come from slider variables</span></span><br><span class="line">            o.Metallic = _Metallic;</span><br><span class="line">            o.Smoothness = _Glossiness;</span><br><span class="line">            o.Alpha = c.a;</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br></pre></td></tr></table></figure><p>上文提到的 surf 函数就是对应这一段。我们看函数头输入的参数有Input IN，这个Input就对应上面的结构体。我们可以把所需要参与计算的数据都放到这个Input结构中，再传入surf函数使用；<strong>SurfaceOutputStandard</strong> 是已经定义好了里面类型输出结构。作为输入的结构体<strong>必须命名为Input</strong>，这个结构体中定义了一个float2的变量，emmmm···你可能会感到奇怪float后面跟着数字，这是什么意思呢？其实float和vec都可以在之后加入一个2到4的数字，来表示被打包在一起的2到4个同类型数。比如：</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float4 color;</span><br><span class="line">float3 multipliedColor = color.rgb * coordinate.x;</span><br></pre></td></tr></table></figure><p>在这个例子里，我们声明了一个叫做 <strong>uv_MainTex</strong> 的包含两个浮点数的变量。UV mapping 的作用是将一个2D贴图上的点按照一定规则映射到3D模型上，在Cg程序中，我们有这样的约定，在一个贴图变量之前加上uv两个字母，就代表提取它的uv值。我们之后就可以在 surf 程序中直接通过访问uv_MainTex 来取得这张贴图当前需要计算的点的坐标值。接下来我们详细看surf内部的操作：</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;</span><br></pre></td></tr></table></figure><p>这里用到了一个tex2d函数，这是Cg程序中用来在一张贴图中对一个点进行采样的方法，返回一个float4。这个例子中用刚刚得到的 float4 和 _Color 相乘，使得这个贴图经过和颜色混合。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o.Albedo = c.rgb;</span><br></pre></td></tr></table></figure><p>将其颜色的rbg值赋予了输出的像素颜色</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">o.Metallic = _Metallic;</span><br><span class="line">o.Smoothness = _Glossiness;</span><br></pre></td></tr></table></figure><p>都是用到上头Properties中我们定义的变量来赋值材质中的 Metallic 和 smoothness</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o.Alpha = c.a;</span><br></pre></td></tr></table></figure><p>将a值赋予透明度。至此surf介绍完毕，这个例子中shader最重要的部分就是以上这些啦！</p><h4 id="FallBack"><a href="#FallBack" class="headerlink" title="FallBack"></a>FallBack</h4><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FallBack <span class="hljs-string">"Diffuse"</span></span><br></pre></td></tr></table></figure><p>当所有上面的SubShader都不可以在目标平台上运行时，Unity就会调用这个shader，当然你也可以关闭这个选项，那就意味着如果没有显卡可以跑上面的shader，我们就不管它啦!</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这是最简单最简单的模板shader，看到这里的你应该可以了解一些简单的shader了，可以去Unity的Surface Shader Exampless上查看一些基础shader的编写内容，下一篇我们会开始第一个shader的编写。</p>]]></content>
      
      
      <categories>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shader、图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>      <title>Unity Shader 入门（二）：Shader介绍</title>
      <link href="/2019/04/29/shader-learning2/"/>
      <url>/2019/04/29/shader-learning2/</url>
>>>>>>> 5a816616ebf74eb2054f09a67ff9fdf655bff8bb
      
        <content type="html"><![CDATA[<h2 id="什么是Shader？"><a href="#什么是Shader？" class="headerlink" title="什么是Shader？"></a>什么是Shader？</h2><p>Shader（着色器）：是渲染管线上的一小段程序，它负责将输入的Mesh（网格）以指定的方式和输入的贴图、颜色等组合作用然后输出。Shader开发者要做的就是根据输入，进行计算变换，产生输出。shader大体上可以分为两类：<br><a id="more"></a></p><ul><li>顶点着色器（Vertex Shader）</li><li>片元着色器（Fragment Shader）</li></ul><p>而在Unity Shader中分为三类：</p><ul><li>Surface Shaders （表面着色器）：是Unity对Vertex/Fragment Shader的一层包装，可以以极少的代码来完成不同的光照模型与不同平台下需要考虑的事情；缺点是能够实现的效果不如片段着色器来的多。</li><li>Vertex/Fragment Shaders （顶点/片断着色器）</li><li>Fixed Function Shaders （固定管线着色器）：已被淘汰</li></ul><h2 id="什么是着色语言HLSL、GLSL、Cg？"><a href="#什么是着色语言HLSL、GLSL、Cg？" class="headerlink" title="什么是着色语言HLSL、GLSL、Cg？"></a>什么是着色语言HLSL、GLSL、Cg？</h2><p>上一篇讲到了很多可编程的着色阶段（例如顶点着色器、片元着色器等等）。之所以称为可编程的着色阶段就是因为可以用一种特定的语言来编写程序，也就是着色语言（Shading language），以下几种常见的着色语言：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:left">API</th><th style="text-align:left">优点</th><th style="text-align:left">缺点</th></tr></thead><tbody><tr><td style="text-align:center">HLSL（High Level Shading Language）</td><td style="text-align:left">Direct3D</td><td style="text-align:left">因为是由微软控制的着色器编译，因此即使是使用了不同的硬件，同一个着色器编译下的结果也都一样</td><td style="text-align:left">支持HLSL的平台有限，几乎都是微软的产品（因为别的平台上没有相应的编译器）</td></tr><tr><td style="text-align:center">GLSL（OpenGL Shading Language）</td><td style="text-align:left">OpenGL</td><td style="text-align:left">因为没有提供着色编译器，而是由显卡驱动来完成着色器的编译工作，因此具有优秀的跨平台性</td><td style="text-align:left">编译的结果取决于硬件提供商（GLSL是依赖硬件而不是操作系统层次的）</td></tr><tr><td style="text-align:center">Cg（C for Graphic）</td><td style="text-align:left">/</td><td style="text-align:left">Cg语言是 OpenGL和 DirectX 的上层，会根据平台的不同编译成不同的中间语言，即 Cg 程序是运行在 OpenGL 和 DirectX 标准顶点和像素着色的基础上的，因此具有真正的跨平台性。因为NVIDIA和微软的合作使得 Cg 和 HLSL 语法非常相像</td><td style="text-align:left">可能无法发挥出 OpenGL 的最新特性</td></tr></tbody></table><h2 id="什么是ShaderLab？"><a href="#什么是ShaderLab？" class="headerlink" title="什么是ShaderLab？"></a>什么是ShaderLab？</h2><p>在Unity中，所有的Shader都是使用ShaderLab来编写的，从结构上来说，它定义了显示一个材质所需要的所有东西，而不仅仅是着色器代码，我们先来看一下ShaderLab的结构</p><p><img src="/2019/04/29/shader-learning2/1.png" alt="Figure 1"></p><p>一个shader包含多个属性（Properties)，然后是一个或多个的子着色器（SubShader)，在实际运行中，哪一个子着色器被使用是由运行的平台所决定的。每一个子着色器中包含一个或者多个的Pass。在计算着色时，平台先选择最优先可以使用的着色器，然后依次运行其中的Pass，然后得到输出的结果。最后指定一个FallBack，用来处理所有Subshader都不能运行的情况,一般FallBack的都是平台已经定义好的shader。</p><h3 id="ShaderLab和着色语言的关系"><a href="#ShaderLab和着色语言的关系" class="headerlink" title="ShaderLab和着色语言的关系"></a>ShaderLab和着色语言的关系</h3><p>对于表面着色器和顶点着色器我们可以在 ShaderLab 的 Pass 中的 CGPROGRAM 和 ENDCG 之间嵌套Cg/HLSL。或者在 GLSLPROGRAM 和 ENDGLSL 之间嵌套 GLSL。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line">    CGPROGRAM</span><br><span class="line">    <span class="hljs-comment">//一些编译指令，例如：</span></span><br><span class="line">    <span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">    <span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> fragment frag</span></span><br><span class="line">    <span class="hljs-comment">//Cg代码</span></span><br><span class="line">    ENDCG</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="ShaderLab的模板"><a href="#ShaderLab的模板" class="headerlink" title="ShaderLab的模板"></a>ShaderLab的模板</h3><p>当我们打开Unity，然后在Project面板点击右键，依次从中选择Create/Shader/…发现会有很多的可选项</p><p><img src="/2019/04/29/shader-learning2/2.png" alt="Figure 1"></p><ul><li>Standard Surface Shader：标准表面着色器，是一种基于物理的着色系统（使用了Physically Based Rendering（简称PBR）技术，即基于物理的渲染技术），以模拟现实真实的方式来模拟材质与灯光之间的关系，可以很轻易的表现出各种金属反光效果，同时此种Shader的书写逻辑也更符合人类的思维模式。</li><li>Unlit Shader：Vertex/Fragment Shader,也就是最基本的顶点片断着色器，不受光照影响的Shader，多用于特效、UI上的效果制作。</li><li>Image Effect Shader：也是顶点片断着色器，只不过是针对后处理而定制的模版，例如调色、景深、模糊等，这些基于最终整个屏幕画面而进行再处理的Shader就是后处理。</li><li>Compute Shader：Compute Shader是运行在图形显卡上的一段程序，独立于常规渲染管线之外的，它可以直接将GPU作为并行处理器加以利用，从而使GPU不仅具有3D渲染能力，还具有其他的运算能力。</li><li>Shader Variant Collection：Shader变体收集器，在上面创建的时候，你会发现Shader Variant Collection与以上四个是被隔开的，就是因为这个与它们不一样，它不是制作Shader的模版，而只是对Shader变体进行打包用的容器。</li></ul><p>注：以上的Standard Surface Shader、Unlit Shader、Image Effect Shader仅仅只是Unity为了方便我们书写而内置的几个模版，你完全可以建一个Unlit Shader，然后将其改成Surface Shader,同样也可以将一个Standard Surface Shader改成顶点片断着色器。</p><h2 id="Shader和Material的关系"><a href="#Shader和Material的关系" class="headerlink" title="Shader和Material的关系"></a>Shader和Material的关系</h2><p>由于在Unity中Shader就是运行在图形显卡上的一段包含指令的代码，所以我们需要再创建一个材质来关联它，这样才能把材质赋给场景中的物体来实现我们想要的效果。总结一下Shader与材质的关系：</p><ul><li>一个Shader可以与无数个材质关联。</li><li>一个材质同一时刻只能关联于一个Shader。（但是我们可以通过代码去动态改变材质所关联的Shader）</li><li>材质可以赋与模型，但是Shader不行。</li><li>材质就像是Shader的实例，每个材质都可以参数不一样呈现不同的效果，但是当Shader改变时，关联它的所有材质都会相应的改变。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shader、图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity Shader 入门（一）：渲染管线</title>
      <link href="/2019/04/28/shader-learning1/"/>
      <url>/2019/04/28/shader-learning1/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是渲染管线？"><a href="#什么是渲染管线？" class="headerlink" title="什么是渲染管线？"></a>什么是渲染管线？</h2><p>Shader（着色器）：是渲染管线上的一小段程序，要了解Shader首先要明白渲染管线是什么呢？</p><p>渲染管线的主要功能是在给定虚拟相机、三维物体、光源、照明模式，以及纹理等诸多<br>条件的情况下，生成或绘制一幅二维图像的过程。对于实时渲染来说，渲染管线就是基础，可以说渲染管线是实时渲染的底层工具。<br><a id="more"></a><br><img src="/2019/04/28/shader-learning1/1.png" alt="在左图中，虚拟相机放在棱椎的顶端黑点（四条线段的交汇点），右图显示的就是此时渲染的图像，只有可视体内部的图元会被渲染。"></p><p>在概念上可以将图形渲染管线分为四个阶段：</p><ul><li>应用程序阶段（The Application）</li><li>几何阶段（The Geometry）</li><li>光栅化阶段（The Rasterizer）</li><li>像素处理阶段（pixel processing）</li></ul><p><img src="/2019/04/28/shader-learning1/2.png" alt="Figure 1.2"></p><p>这里有几个要点：</p><ul><li>每个阶段本身也可能是一条管线，如图中的几何阶段所示。此外，还可以对有的阶段进行全部或者部分的并行化处理，如图中的像素处理阶段。应用程序阶段虽然是一个单独的过程，但是依然可以对之进行管线化或者并行化处理。</li><li>最慢的管线阶段决定绘制速度，即图像的更新速度，这种速度一般用 <strong>frames per second(FPS)</strong> 来表示，也就是每秒绘制的图像数量，或者用 <strong>Hertz (Hz)</strong> 来表示。</li></ul><h2 id="应用程序阶段-The-Application-Stage"><a href="#应用程序阶段-The-Application-Stage" class="headerlink" title="应用程序阶段 The Application Stage"></a>应用程序阶段 The Application Stage</h2><p>顾名思义，应用程序阶段是由应用程序驱动的，一般是图形渲染管线概念上的第一个阶段。开发者能够对该阶段发生的情况进行完全控制，可以通过改变实现方法来改变实际性能，可以做的任务包括：</p><ul><li>碰撞检测、输入检测、力反馈</li><li>纹理动画、变换仿真、几何形变</li><li>等等</li></ul><p>在其他阶段是全部或者部分建立在硬件基础上，因此要改变实现过程会非常困难。</p><p>正因应用程序阶段是软件方式实现，因此不能像几何和光栅化阶段那样继续分为若干个子阶段。但为了提高性能，该阶段还是可以在几个并行处理器上同时执行。在 CPU 设计上，称这种形式为超标量体系（superscalar）结构，因为它可以在同一阶段同一时间做不同的几件事情。</p><p>应用程序阶段通常完成一些不在其他阶段执行的计算，如层次视锥裁剪等加速算法就可以在这里实现。</p><p>应用程序阶段的主要任务：在应用程序阶段的末端，将需要在屏幕上（具体形式取决于具体输入设备）显示出来绘制的几何体（也就是绘制图元(rendering primitives)：如点、线、矩形等）、以及摄像机位置输入到绘制管线的下一个阶段————几何阶段。</p><h2 id="几何阶段-The-Geometry-Stage"><a href="#几何阶段-The-Geometry-Stage" class="headerlink" title="几何阶段 The Geometry Stage"></a>几何阶段 The Geometry Stage</h2><p>这个阶段用于处理几乎所有我们要绘制的几何相关的事情，比如决定画什么、怎么画、画在哪里等等（这一段主要在GPU上进行），因为事情太多，因此可以进一步细分成一个小的流水线：</p><ul><li>顶点着色 Vertex Shading</li><li>投影 Projection</li><li>裁剪 Clipping</li><li>屏幕映射 Screen Mapping</li></ul><p><img src="/2019/04/28/shader-learning1/3.png" alt="Figure 3.1"></p><h3 id="顶点着色-Vertex-Shading"><a href="#顶点着色-Vertex-Shading" class="headerlink" title="顶点着色 Vertex Shading"></a>顶点着色 Vertex Shading</h3><p>顶点着色 Vertex Shading 阶段主要的任务是：</p><ul><li>计算顶点的位置</li><li>计算程序员要的顶点的输出数据例如：法线、纹理贴图坐标等等</li></ul><p>一般来说, 模型大部分的着色是通过：计算光源作用于每个顶点的位置、法线信息的结果，存储时仅存储顶点处的颜色，然后在三角形上插值这些颜色来得到的。顶点着色器现在是一个更通用的部分, 专门用于设置与每个顶点关联的数据比如可以用于顶点绑定、图像变换等等。</p><p>在绘制到屏幕上之前，模型通常需要变换到若干不同的空间或坐标系中。模型变换的变换对象一般是模型的顶点和法线。物体的坐标称为模型坐标。世界空间是唯一的，所有的模型经过变换后都位于同一个空间中。</p><p>就像上文提到，应该仅对相机（或者视点）可以看到的模型进行绘制，而相机在世界空间中有一个位置和一个方向。为了方便投影和裁剪，必须对相机和所有的模型进行视点变换。变换的目的就是要把相机放在原点，然后进行视点校准，使其朝向 Z 轴负方向，y 轴指向上方,x 轴指向右边。在视点变换后，实际位置和方向就依赖于当前的 API。我们称上述空间为相机空间或者观察空间，下图显示了视点变换对相机和模型的影响。</p><p><img src="/2019/04/28/shader-learning1/4.png" alt="Figure 3.2 在左图中，摄像机根据用户指定的位置进行放置和定位。在右图中，视点变换从原点沿着 Z 轴负方向对相机重新定位，这样可以使裁剪和投影操作更简单、更快速。可视范围是一个平截椎体，因此可以认为它是透视模式。"></p><p>为了产生逼真的场景，仅仅渲染形状和位置是远远不够的，我们需要对物体的外观进行建模。而物体经过建模，会得到对包括每个对象的材质，以及照射在对象上的任何光源的效果在内的一些刻画。且光照和材质可以用任意数量的方式，从简单的颜色描述到复杂的物理描述来模拟。</p><p>确定材质上的光照效果的这种操作被称为着色（shading），着色过程涉及在对象上的各个点处计算着色方程（shading equation）。通常，这些计算中的一些在几何阶段期间在模型的顶点上执行（vertex shading），而其他计算可以在每像素光栅化（per-pixel rasterization）期间执行。可以在每个顶点处存储各种材料数据，诸如点的位置，法线，颜色或计算着色方程所需的任何其它数字信息。顶点着色的结果（其可以是颜色，向量，纹理坐标或任何其他种类的着色数据）计算完成后，会被发送到光栅化阶段以进行插值操作。</p><p>着色计算通常认为是在世界空间中进行的。在实践中，有时需要将相关实体（诸如相机和光源）转换到一些其它空间（诸如模型或观察空间）并在那里执行计算，也可以得到正确的结果。这是因为如果着色过程中所有的实体变换到了相同的空间，着色计算中需要的诸如光源，相机和模型之间的相对关系是不会变的。</p><h3 id="投影-Projection"><a href="#投影-Projection" class="headerlink" title="投影 Projection"></a>投影 Projection</h3><p>在光照处理之后，渲染系统就开始进行投影操作，即将视体变换到一个对角顶点分别是 (-1,-1,-1) 和 (1,1,1) 单位立方体（unit cube）内，这个单位立方体通常也被称为规范视域体（Canonical View Volume，CVV）。目前，主要有两种投影方法，即：</p><ul><li>正交投影（orthographic projection，或称 parallel projection）：正交投影的可视体通常是一个矩形，正交投影可以把这个视体变换为单位立方体。正交投影的主要特性是平行线在变换之后彼此之间仍然保持平行，这种变换是平移与缩放的组合。</li><li>透视投影（perspective projection）：相比之下，透视投影比正交投影复杂一些。在这种投影中，越远离摄像机的物体，它在投影后看起来越小。更进一步来说，平行线将在地平线处会聚。透视投影的变换其实就是模拟人类感知物体的方式。</li></ul><p><img src="/2019/04/28/shader-learning1/5.png" alt="Figure 3.3 左边为正交投影，右边为透视投影"></p><p>正交投影和透视投影都可以通过 4 x 4 的矩阵来实现，在任何一种变换之后，都可以认为模型位于归一化处理之后的设备坐标系中。虽然这些矩阵变换是从一个可视体变换到另一个，但它们仍被称为投影，因为在完成显示后，Z 坐标将不会再保存于的得到的投影图片中。通过这样的投影方法，就<strong>将模型从三维空间投影到了二维的空间中</strong>。</p><h3 id="可选择的顶点处理"><a href="#可选择的顶点处理" class="headerlink" title="可选择的顶点处理"></a>可选择的顶点处理</h3><p>这一部分是这个流水线上的可选项，不一定必须经历这个环节，是否启用取决于硬件的条件，这些环节彼此之间是相互独立的，按照顺序是：</p><ul><li>曲面细分 tessellation：例如我们用三角形来描绘物体，理论上将三角形划分的越细物体也就越精细，如果这个物体离摄像头很远或者只在摄像头内出现一角，花费大量的三角形细分就比较浪费资源了。但在应用曲面细分，曲面就可以用适当的三角形数来生成。</li><li>几何元着色 geometry shading：这个阶段的作用和曲面细分类似，都可以生成新的顶点，但这是一个输出与输入的图元都受限的阶段，相应的也较为简单快速。最广泛应用这个阶段的地方可能是 <strong>生成粒子</strong> 例如烟火效果，每一点火星就好像一个点，几何元着色可以将这个点由一个面对观众的正方形（两个三角形组成）来表示，这更方便我们渲染图元。</li><li>流式输出 stream output：这个阶段让我将GPU当作几何引擎，这个阶段我们不是把数据传给剩余的流水线去处理，而是可以选择将它们输出到数组以进行进一步处理，这些数据可以给CPU，或者GPU自己，这个阶段在经常用于生成粒子，例如上面烟火的例子。</li></ul><h3 id="裁剪-Clipping"><a href="#裁剪-Clipping" class="headerlink" title="裁剪 Clipping"></a>裁剪 Clipping</h3><p>只有当图元完全或部分存在于视体（也就是上文的规范视域体CVV）内部的时候，才需要将其发送到光栅化阶段，这个阶段可以把这些图元在屏幕上绘制出来。显然一个图元相对视体内部的位置，分为三种情况：完全位于内部、完全位于外部、部分位于内部。所以就要分情况进行处理：</p><ul><li>当图元完全位于视体内部：那么它可以直接进行下一个阶段。</li><li>当图元完全位于视体外部：不会进入下一个阶段，可直接丢弃，因为它们无需进行渲染。</li><li>当图元部分位于视体内部：则需要对那些部分位于视体内的图元进行裁剪处理。对部分位于视体内部的图元进行裁剪操作，这就是裁剪过程存在的意义。裁剪过程见下图。</li></ul><p><img src="/2019/04/28/shader-learning1/6.png" alt="Figure 3.4 投影变换后，只对单位立方体内的图元继续进行处理，同时沿着单位立方体将与单位立方体相交的图元裁剪掉，因此会产生新的图元，同时舍弃旧的图元。"></p><h3 id="屏幕映射-Screen-Mapping"><a href="#屏幕映射-Screen-Mapping" class="headerlink" title="屏幕映射 Screen Mapping"></a>屏幕映射 Screen Mapping</h3><p>只有在视体内部经过裁剪的图元，以及之前完全位于视体内部的图元，才可以进入到屏幕映射阶段。进入到这个阶段时，坐标仍然是三维的（但显示状态在经过投影阶段后已经成了二维），每个图元的 x 和 y 坐标变换到了屏幕坐标系中，屏幕坐标系连同 z 坐标一起称为窗口坐标系。假定在一个窗口里对场景进行绘制，窗口的最小坐标为（x1，y1），最大坐标为（x2，y2），其中 x1 &lt; x2，y1 &lt; y2。屏幕映射首先进行平移，随后进行缩放，在映射过程中 z 坐标不受影响。新的 x 和 y 坐标称为屏幕坐标系，与 z 坐标一起（OpenGL下是[-1,+1]，DirectX下是[0,1]）进入光栅化阶段。如下图：</p><p><img src="/2019/04/28/shader-learning1/7.png" alt="Figure 3.5 经过投影变换，图元全部位于单位立方体之内，而屏幕映射主要目的就是找到屏幕上对应的坐标"></p><p>屏幕映射阶段的一个常见困惑是整型和浮点型的点值如何与像素坐标（或纹理坐标）进行关联。因为像素的中点可以定义在0.5处，因此索引在[0,9]之内的像素可以表示的浮点范围在[0.0,10.0)之内，这个转换可以简单的通过以下来转变：<br>$$d=floor(c)$$<br>$$c=d+0.5$$<br>其中 d 是像素的整数索引, c 是像素内的浮点值。</p><h2 id="光栅化阶段-The-Rasterizer-Stage"><a href="#光栅化阶段-The-Rasterizer-Stage" class="headerlink" title="光栅化阶段 The Rasterizer Stage"></a>光栅化阶段 The Rasterizer Stage</h2><p>给定经过变换和投影之后的顶点，颜色以及纹理坐标（均来自于几何阶段），给每个像素（Pixel）正确配色，以便正确绘制整幅图像。这个过个过程叫光珊化（rasterization）这个阶段主要分成两部分：三角形设定（Triangle Setup）也被称为图元装配和三角形遍历（Triangle Traversal），即从二维顶点所处的屏幕空间（所有顶点都包含 Z 值即深度值，及各种与相关的着色信息）到屏幕上的像素的转换。</p><p><img src="/2019/04/28/shader-learning1/8.png" alt="Figure 4 光栅化阶段一般细分为三角形设定和三角形遍历两个子阶段。"></p><h3 id="三角形设定-Triangle-Setup"><a href="#三角形设定-Triangle-Setup" class="headerlink" title="三角形设定 Triangle Setup"></a>三角形设定 Triangle Setup</h3><p>三角形设定阶段主要用来计算三角形表面差异和边缘方程等其他相关数据。该数据主要用于扫描转换（scan conversion），以及由几何阶段处理的各种着色数据的插值操作所用，该过程在专门为其设计的硬件上执行。</p><h3 id="三角形遍历-Triangle-Traversal"><a href="#三角形遍历-Triangle-Traversal" class="headerlink" title="三角形遍历 Triangle Traversal"></a>三角形遍历 Triangle Traversal</h3><p>在三角形遍历阶段将进行逐像素检查操作，检查该像素处的像素中心是否由三角形覆盖，而对于有三角形部分重合的像素，将在其重合部分生成片段（fragment）。找到哪些采样点或像素在三角形中的过程通常叫三角形遍历（TriangleTraversal）或扫描转换（scan conversion）。每个三角形片段的属性均由三个三角形顶点的数据插值而生成。这些属性包括片段的深度，以及来自几何阶段的着色数据。</p><h2 id="像素处理-Pixel-Processing"><a href="#像素处理-Pixel-Processing" class="headerlink" title="像素处理 Pixel Processing"></a>像素处理 Pixel Processing</h2><p>在这个阶段，所有的像素已经都在一个三角形中或者是前面一系列处理之后的图元下，像素处理阶段被分为像素着色和融合两个子阶段</p><p><img src="/2019/04/28/shader-learning1/9.png" alt="Figure 5 像素处理阶段一般细分为像素着色和融合两个子阶段。"></p><h3 id="像素着色-Pixel-Shading"><a href="#像素着色-Pixel-Shading" class="headerlink" title="像素着色 Pixel Shading"></a>像素着色 Pixel Shading</h3><p>所有逐像素的着色计算都在像素着色阶段进行，使用插值得来的着色数据作为输入，输出结果为一种或多种将被传送到下一阶段的颜色信息。纹理贴图操作就是在这阶段进行的。像素着色阶段是在可编程 GPU 内执行的，在这一阶段有大量的技术可以使用，其中最常见，最重要的技术之一就是纹理贴图（Texturing）。纹理贴图在书的第六章会详细讲到。简单来说，纹理贴图就是将指定图片“贴”到指定物体上的过程。而指定的图片可以是一维，二维，或者三维的，其中，自然是二维图片最为常见。如下图所示：</p><p><img src="/2019/04/28/shader-learning1/10.png" alt="Figure 6 左上角为一没有纹理贴图的飞龙模型。左下角为一贴上图像纹理的飞龙。右图为所用的纹理贴图。"></p><h3 id="融合-Merging"><a href="#融合-Merging" class="headerlink" title="融合 Merging"></a>融合 Merging</h3><p>每个像素的信息都储存在颜色缓冲器中，而颜色缓冲器是一个颜色的矩阵列（每种颜色包含红、绿、蓝三个分量）。融合阶段的主要任务是合成当前储存于缓冲器中的由之前的像素着<br>色阶段产生的片段颜色。不像其它着色阶段，通常运行该阶段的 GPU 子单元并非完全可编程的，但其高度可配置，可支持多种特效。</p><p>这个阶段还负责可见性问题的处理。这意味着当绘制完整场景的时候，颜色缓冲器中应该还包含从相机视点处可以观察到的场景图元。对于大多数图形硬件来说，这个过程是通过 Z 缓冲（也称深度缓冲器）算法来实现的。Z 缓冲算法非常简单，具有 $O(n)$ 复杂度（n 是需要绘制的像素数量），只要对每个图元计算出相应的像素 z 值，就可以使用这种方法，大概内容是：</p><ul><li>Z 缓冲器和颜色缓冲器形状大小一样，每个像素都存储着一个 z 值，这个 z 值是从相机到最近图元之间的距离。</li><li>每次将一个图元绘制为相应像素时，需要计算像素位置处图元的 z 值，并与同一像素处的 z 缓冲器内容进行比较。</li><li>如果新计算出的 z 值，远远小于 Z 缓冲器中的 z 值，那么说明即将绘制的图元与相机的距离比原来距离相机最近的图元还要近。这样像素的 z 值和颜色就由当前图元对应的值和颜色进行更新。反之，若计算出的 z 值远远大于 z 缓冲器中的 z 值，那么 z 缓冲器和颜色缓冲器中的值就无需改变。</li><li>值得注意的是这个算法不能用于渲染半透明物体，原因我们会在往后的文章解释</li></ul><p>颜色缓冲器用来存储颜色，z 缓冲器用来存储每个像素的 z 值，还有其他缓冲器可以用来过滤和捕获片段信息。</p><ul><li>比如 alpha 通道（alpha channel）和颜色缓冲器联系在一起可以存储一个与每个像素相关的不透明值。可选的 alpha 测试可在深度测试执行前在传入片段上运行。片段的 alpha 值与参考值作某些特定的测试（如等于，大于等），如果片断未能通过测试，它将不再进行进一步的处理。alpha 测试经常用于不影响深度缓存的全透明片段的处理。</li><li>模板缓冲器（stencil buffer）是用于记录所呈现图元位置的离屏缓存。每个像素通常与占用 8 个位。图元可使用各种方法渲染到模板缓冲器中，而缓冲器中的内容可以控制颜色缓存和 Z 缓存的渲染。举个例子，假设在模版缓冲器中绘制出了一个实心圆形，那么可以使用一系列操作符来将后续的图元仅在圆形所出现的像素处绘制，类似一个 mask 的操作。模板缓冲器是制作特效的强大工具。而在管线末端的所有这些功能都叫做光栅操作（raster operations ，ROP）或混合操作（blend operations）可以将颜色缓冲区中当前的颜色与在三角形内处理的像素的颜色混合，这样可以实现半透明或者颜色累积的效果。</li><li>帧缓冲器（frame buffer）通常包含一个系统所具有的所有缓冲器，但有时也可以认为是颜色缓冲器和 Z 缓冲器的组合。</li></ul><p>而当图元通过光栅化阶段之后，从相机视点处看到的东西就可以在荧幕上显示出来。为了避免观察者体验到对图元进行处理并发送到屏幕的过程，图形系统一般使用了双缓冲（double buffering）机制，这意味着屏幕绘制是在一个后置缓冲器（back buffer）中以离屏的方式进行的。一旦屏幕已在后置缓冲器中绘制，后置缓冲器中的内容就不断与已经在屏幕上显示过的前置缓冲器中的内容进行交换，当然，只有当不影响显示的时候才进行交换。</p>]]></content>
      
      
      <categories>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shader、图形学 </tag>
            
        </tags>
      
    </entry>
    
<<<<<<< HEAD
=======
    
    
>>>>>>> 9e62def5d865150fae5440cc55e3c06c4faf11a3
    <entry>
      <title>Unity Shader 入门（六）：模型描边Shader</title>
      <link href="/2018/02/08/Unity%20Shader%20%E5%85%A5%E9%97%A8%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E6%A8%A1%E5%9E%8B%E6%8F%8F%E8%BE%B9Shader/"/>
      <url>/2018/02/08/Unity%20Shader%20%E5%85%A5%E9%97%A8%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E6%A8%A1%E5%9E%8B%E6%8F%8F%E8%BE%B9Shader/</url>
      
        <content type="html"><![CDATA[<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>前面几篇我们写了几个边缘发光的shader，另外一个类似功能的就是模型描边，和边缘发光不同的地方在于，描边是在原有模型的基础上，添加一圈的外框。</p><p>老规矩还是来看一下效果图：<br><a id="more"></a><br><img src="https://github.com/kurong00/blog/blob/master/thumbnail/shader6/RimLighting.PNG?raw=true" alt></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>说明一下这个Shader的具体实现：</p><h3 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a>实现原理：</h3><p>Mesh Doubling (复制网格)： </p><ol><li>需要一个单独的Pass来实现，重新绘制一个将所有表面都<font color="#D37885">沿着法线方向</font>延展模型，挤出一点点，然后将正面剪裁掉，只输出描边的颜色；</li><li>第二个Pass就是一个正常着色的Pass</li></ol><h3 id="具体解说："><a href="#具体解说：" class="headerlink" title="具体解说："></a>具体解说：</h3><p>先放一段实现的代码：<br><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="hljs-string">"Custom/Rim/RimLighting"</span> &#123;</span><br><span class="line">Properties&#123;</span><br><span class="line">_MainColor(<span class="hljs-string">"Main Color"</span>, Color) = (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span><br><span class="line">_OutlineCol(<span class="hljs-string">"OutlineCol"</span>, Color) = (<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)</span><br><span class="line">_OutlineFactor(<span class="hljs-string">"OutlineFactor"</span>, Range(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)) = <span class="hljs-number">0.1</span></span><br><span class="line">_MainTex(<span class="hljs-string">"Base 2D"</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">"white"</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-comment">//描边使用两个Pass，第一个pass沿法线挤出一点，只输出描边的颜色</span></span><br><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">Cull Front</span><br><span class="line">CGPROGRAM</span><br><span class="line">#include <span class="hljs-string">"UnityCG.cginc"</span></span><br><span class="line">fixed4 _OutlineCol;</span><br><span class="line"><span class="hljs-keyword">float</span> _OutlineFactor;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">v2f</span></span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">float4 pos : SV_POSITION;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function">v2f <span class="hljs-title">vert</span><span class="hljs-params">(appdata_full v)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">v2f o;</span><br><span class="line">o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"><span class="hljs-comment">//将法线方向转换到视空间</span></span><br><span class="line">float3 vnormal = mul((float3x3)UNITY_MATRIX_IT_MV, v.normal);</span><br><span class="line"><span class="hljs-comment">//将视空间法线xy坐标转化到投影空间，只有xy需要，z深度不需要了</span></span><br><span class="line">float2 offset = TransformViewToProjection(vnormal.xy);</span><br><span class="line"><span class="hljs-comment">//在最终投影阶段输出进行偏移操作</span></span><br><span class="line">o.pos.xy += offset * _OutlineFactor;</span><br><span class="line"><span class="hljs-keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fixed4 frag(v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-comment">//这个Pass直接输出描边颜色</span></span><br><span class="line"><span class="hljs-keyword">return</span> _OutlineCol;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//使用vert函数和frag函数</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> vertex vert</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> fragment frag</span></span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//正常着色的Pass</span></span><br><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">CGPROGRAM</span><br><span class="line"><span class="hljs-comment">//引入头文件</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Lighting.cginc"</span></span></span><br><span class="line"><span class="hljs-comment">//使用vert函数和frag函数</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> vertex vert</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"><span class="hljs-comment">//定义Properties中的变量</span></span><br><span class="line">fixed4 _MainColor;</span><br><span class="line">sampler2D _MainTex;</span><br><span class="line"><span class="hljs-comment">//定义结构体：vertex shader阶段输出的内容</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">v2f</span></span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">float4 pos : SV_POSITION;</span><br><span class="line">float3 worldNormal : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">//定义顶点shader,参数直接使用appdata_base（包含position, noramal, texcoord）</span></span><br><span class="line"><span class="hljs-function">v2f <span class="hljs-title">vert</span><span class="hljs-params">(appdata_base v)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">v2f o;</span><br><span class="line">o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"><span class="hljs-comment">//通过TRANSFORM_TEX宏转化纹理坐标，主要处理了Offset和Tiling的改变</span></span><br><span class="line">o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);</span><br><span class="line"><span class="hljs-keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//定义片元shader</span></span><br><span class="line">fixed4 frag(v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-comment">//unity自身的diffuse也是带了环境光，这里我们也增加一下环境光</span></span><br><span class="line">fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * _MainColor.xyz;</span><br><span class="line"><span class="hljs-comment">//归一化法线，即使在vert归一化也不行，从vert到frag阶段有差值处理，传入的法线方向并不是vertex shader直接传出的</span></span><br><span class="line">fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line"><span class="hljs-comment">//把光照方向归一化</span></span><br><span class="line">fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line"><span class="hljs-comment">//根据半兰伯特模型计算像素的光照信息</span></span><br><span class="line">fixed3 lambert = <span class="hljs-number">0.5</span> * dot(worldNormal, worldLightDir) + <span class="hljs-number">0.5</span>;</span><br><span class="line"><span class="hljs-comment">//最终输出颜色为lambert光强*材质diffuse颜色*光颜色</span></span><br><span class="line">fixed3 diffuse = lambert * _MainColor.xyz * _LightColor0.xyz + ambient;</span><br><span class="line"><span class="hljs-comment">//进行纹理采样</span></span><br><span class="line">fixed4 color = _MainColor;</span><br><span class="line">color.rgb = color.rgb* diffuse;</span><br><span class="line"><span class="hljs-keyword">return</span> fixed4(color);</span><br><span class="line">&#125;</span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">FallBack <span class="hljs-string">"Diffuse"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>详细的实现，包含在注释之中了。</p><h3 id="包含问题"><a href="#包含问题" class="headerlink" title="包含问题"></a>包含问题</h3><p>但是这个实现方法有一个问题：<strong>线条并不连续</strong>，在平滑表面的表现尚可（球体，胶囊体等等），但是在锐利的表面上经常会出现断层（比如立方体等等）。还是利用Mesh Doubling (复制网格)的方法，但是不再简单只通过法线方向，而是：<font color="#D37885">不严格地按照表面沿着法线的方向延展, 而是在标准化的点位置和法线方向之间取一个恰当的参数来做插值</font>。</p><h2 id="更新方案"><a href="#更新方案" class="headerlink" title="更新方案"></a>更新方案</h2><p>修改描边Pass的vert函数：</p><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">v2f vert(appdata_full v)</span><br><span class="line">&#123;</span><br><span class="line">v2f o;</span><br><span class="line">o.pos = UnityObjectToClipPos ( v.vertex );</span><br><span class="line">float3 vnormal1 = normalize ( v.vertex.xyz );</span><br><span class="line"><span class="hljs-comment">//将法线方向转换到视空间</span></span><br><span class="line">float3 vnormal2 = mul((float3x3)UNITY_MATRIX_IT_MV, v.normal);</span><br><span class="line">vnormal1 = lerp ( vnormal1, vnormal2, _Factor );</span><br><span class="line">vnormal1 = mul ( ( float3x3 ) UNITY_MATRIX_IT_MV, vnormal1);</span><br><span class="line">float2 offset = TransformViewToProjection (vnormal1.xy );</span><br><span class="line">offset = normalize ( offset );</span><br><span class="line">float dist = distance ( mul ( UNITY_MATRIX_M, v.vertex ), _WorldSpaceCameraPos );</span><br><span class="line">o.pos.xy += offset *_OutlineFactor;</span><br><span class="line"><span class="hljs-keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的_Factor就是用来计算差值的参数，这个可以根据自己调节<code>lerp ( vnormal1, vnormal2, _Factor )</code></p><p>效果是：<img src="https://github.com/kurong00/blog/blob/master/thumbnail/shader6/RimLightingFix.PNG?raw=true" alt></p><p>最后上一个完整的修复过的Shader方案：</p><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="hljs-string">"Custom/Rim/RimLightingFix"</span> &#123;</span><br><span class="line">Properties&#123;</span><br><span class="line">_MainColor(<span class="hljs-string">"Main Color"</span>, Color) = (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span><br><span class="line">_OutlineCol(<span class="hljs-string">"OutlineCol"</span>, Color) = (<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)</span><br><span class="line">_OutlineFactor(<span class="hljs-string">"OutlineFactor"</span>, Range(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)) = <span class="hljs-number">0.1</span></span><br><span class="line">_MainTex(<span class="hljs-string">"Base 2D"</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">"white"</span>&#123;&#125;</span><br><span class="line">_Factor(<span class="hljs-string">"Control Factor"</span>,Range(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)) = <span class="hljs-number">0.1</span> </span><br><span class="line">&#125;</span><br><span class="line">SubShader</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-comment">//描边使用两个Pass，第一个pass沿法线挤出一点，只输出描边的颜色</span></span><br><span class="line">Pass&#123;</span><br><span class="line">Cull Front</span><br><span class="line">CGPROGRAM</span><br><span class="line"><span class="hljs-meta">#include "UnityCG.cginc"</span></span><br><span class="line"><span class="hljs-comment">//使用vert函数和frag函数</span></span><br><span class="line"><span class="hljs-meta">#pragma vertex vert</span></span><br><span class="line"><span class="hljs-meta">#pragma fragment frag</span></span><br><span class="line">fixed4 _OutlineCol;</span><br><span class="line">float _OutlineFactor;</span><br><span class="line">float _Factor;</span><br><span class="line">struct v2f</span><br><span class="line">&#123;</span><br><span class="line">float4 pos : <span class="hljs-type">SV_POSITION</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">v2f vert(appdata_full v)</span><br><span class="line">&#123;</span><br><span class="line">v2f o;</span><br><span class="line">o.pos = UnityObjectToClipPos ( v.vertex );</span><br><span class="line">float3 vnormal1 = normalize ( v.vertex.xyz );</span><br><span class="line"><span class="hljs-comment">//将法线方向转换到视空间</span></span><br><span class="line">float3 vnormal2 = mul((float3x3)UNITY_MATRIX_IT_MV, v.normal);</span><br><span class="line">vnormal1 = lerp ( vnormal1, vnormal2, _Factor );</span><br><span class="line">vnormal1 = mul ( ( float3x3 ) UNITY_MATRIX_IT_MV, vnormal1);</span><br><span class="line">float2 offset = TransformViewToProjection (vnormal1.xy );</span><br><span class="line">offset = normalize ( offset );</span><br><span class="line">float dist = distance ( mul ( UNITY_MATRIX_M, v.vertex ), _WorldSpaceCameraPos );</span><br><span class="line">o.pos.xy += offset *_OutlineFactor;</span><br><span class="line"><span class="hljs-keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fixed4 frag(v2f i) : <span class="hljs-type">SV_Target</span></span><br><span class="line"><span class="hljs-type"></span>&#123;</span><br><span class="line"><span class="hljs-comment">//这个Pass直接输出描边颜色</span></span><br><span class="line"><span class="hljs-keyword">return</span> _OutlineCol;</span><br><span class="line">&#125;</span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//正常着色的Pass</span></span><br><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">CGPROGRAM</span><br><span class="line"><span class="hljs-comment">//引入头文件</span></span><br><span class="line"><span class="hljs-meta">#include "Lighting.cginc"</span></span><br><span class="line"><span class="hljs-comment">//使用vert函数和frag函数</span></span><br><span class="line"><span class="hljs-meta">#pragma vertex vert</span></span><br><span class="line"><span class="hljs-meta">#pragma fragment frag</span></span><br><span class="line"><span class="hljs-comment">//定义Properties中的变量</span></span><br><span class="line">fixed4 _MainColor;</span><br><span class="line">sampler2D _MainTex;</span><br><span class="line"><span class="hljs-comment">//定义结构体：vertex shader阶段输出的内容</span></span><br><span class="line">struct v2f</span><br><span class="line">&#123;</span><br><span class="line">float4 pos : <span class="hljs-type">SV_POSITION</span>;</span><br><span class="line">float3 worldNormal : <span class="hljs-type">TEXCOORD0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">//定义顶点shader,参数直接使用appdata_base（包含position, noramal, texcoord）</span></span><br><span class="line">v2f vert(appdata_base v)</span><br><span class="line">&#123;</span><br><span class="line">v2f o;</span><br><span class="line">o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"><span class="hljs-comment">//通过TRANSFORM_TEX宏转化纹理坐标，主要处理了Offset和Tiling的改变</span></span><br><span class="line">o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);</span><br><span class="line"><span class="hljs-keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//定义片元shader</span></span><br><span class="line">fixed4 frag(v2f i) : <span class="hljs-type">SV_Target</span></span><br><span class="line"><span class="hljs-type"></span>&#123;</span><br><span class="line"><span class="hljs-comment">//unity自身的diffuse也是带了环境光，这里我们也增加一下环境光</span></span><br><span class="line">fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * _MainColor.xyz;</span><br><span class="line"><span class="hljs-comment">//归一化法线，即使在vert归一化也不行，从vert到frag阶段有差值处理，传入的法线方向并不是vertex shader直接传出的</span></span><br><span class="line">fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line"><span class="hljs-comment">//把光照方向归一化</span></span><br><span class="line">fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line"><span class="hljs-comment">//根据半兰伯特模型计算像素的光照信息</span></span><br><span class="line">fixed3 lambert = <span class="hljs-number">0.5</span> * dot(worldNormal, worldLightDir) + <span class="hljs-number">0.5</span>;</span><br><span class="line"><span class="hljs-comment">//最终输出颜色为lambert光强*材质diffuse颜色*光颜色</span></span><br><span class="line">fixed3 diffuse = lambert * _MainColor.xyz * _LightColor0.xyz + ambient;</span><br><span class="line"><span class="hljs-comment">//进行纹理采样</span></span><br><span class="line">fixed4 color = _MainColor;</span><br><span class="line">color.rgb = color.rgb* diffuse;</span><br><span class="line"><span class="hljs-keyword">return</span> fixed4(color);</span><br><span class="line">&#125;</span><br><span class="line">ENDCG</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">FallBack <span class="hljs-string">"Diffuse"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>描边常用于一些漫画风格的游戏场景中，能够在复杂的场景中突出被绘制的物体。</p>]]></content>
      
      
      <categories>
          
          <category> Shader </category>
          
      </categories>
      
      
    </entry>
    
<<<<<<< HEAD
=======
    
    
>>>>>>> 9e62def5d865150fae5440cc55e3c06c4faf11a3
    <entry>
      <title>Unity Shader 入门（五）：边缘发光透明版</title>
      <link href="/2017/11/25/Unity%20Shader%20%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E8%BE%B9%E7%BC%98%E5%8F%91%E5%85%89%E9%80%8F%E6%98%8E%E7%89%88/"/>
      <url>/2017/11/25/Unity%20Shader%20%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E8%BE%B9%E7%BC%98%E5%8F%91%E5%85%89%E9%80%8F%E6%98%8E%E7%89%88/</url>
      
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
        <content type="html"><![CDATA[<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>之前我们写过一个边缘发光的Shader（<a href="http://chenwenling.cn/2017/11/13/Unity%20Shader%20%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAShader/" target="_blank" rel="noopener">传送门</a>），这一次我们来写这个的升级版：透明物体的边缘发光。</p><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p>首先我们还是来看一下效果图：<br><img src="https://github.com/kurong00/blog/blob/master/thumbnail/shader5/RimEnerge.PNG?raw=true" alt></p><h2 id="Shader代码"><a href="#Shader代码" class="headerlink" title="Shader代码"></a>Shader代码</h2><pre class=" language-haxe"><code class="language-haxe">Shader <span class="token string">"Custom/Rim/RimEnerge"</span> <span class="token punctuation">{</span>    Properties    <span class="token punctuation">{</span>        <span class="token function">_Color</span><span class="token punctuation">(</span><span class="token string">"Main Color"</span><span class="token punctuation">,</span>Color<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0.6</span><span class="token punctuation">,</span><span class="token number">0.6</span><span class="token punctuation">,</span><span class="token number">0.6</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token function">_AlphaRange</span><span class="token punctuation">(</span><span class="token string">"Alpha Range"</span><span class="token punctuation">,</span><span class="token function">Range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span>        <span class="token function">_RimColor</span><span class="token punctuation">(</span><span class="token string">"Rim Color"</span><span class="token punctuation">,</span>Color<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    SubShader    <span class="token punctuation">{</span>        Tags<span class="token punctuation">{</span>             <span class="token string">"Queue"</span><span class="token operator">=</span><span class="token string">"Transparent"</span>            <span class="token string">"IgnoreProjector"</span><span class="token operator">=</span><span class="token string">"True"</span>            <span class="token string">"RenderType"</span><span class="token operator">=</span><span class="token string">"Transparent"</span> <span class="token punctuation">}</span>            ZWrite Off         Blend SrcAlpha OneMinusSrcAlpha         LOD <span class="token number">200</span>                 Pass        <span class="token punctuation">{</span>            CGPROGRAM            <span class="token preprocessor builtin">#pragma</span> vertex vert            <span class="token preprocessor builtin">#pragma</span> fragment frag            <span class="token preprocessor builtin">#include</span> <span class="token string">"Lighting.cginc"</span>                  struct a2v            <span class="token punctuation">{</span>                float4 vertex <span class="token punctuation">:</span> POSITION<span class="token punctuation">;</span>                float3 normal <span class="token punctuation">:</span> NORMAL<span class="token punctuation">;</span>                         <span class="token punctuation">}</span><span class="token punctuation">;</span>            struct v2f            <span class="token punctuation">{</span>                float4 pos <span class="token punctuation">:</span> SV_POSITION<span class="token punctuation">;</span>                float3 normalDir <span class="token punctuation">:</span> TEXCOORD0<span class="token punctuation">;</span>                float3 worldPos <span class="token punctuation">:</span> TEXCOORD1<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>            fixed4 _Color<span class="token punctuation">;</span>            float _AlphaRange<span class="token punctuation">;</span>            fixed4 _RimColor<span class="token punctuation">;</span>            v2f <span class="token function">vert</span><span class="token punctuation">(</span> a2v v <span class="token punctuation">)</span>            <span class="token punctuation">{</span>                v2f o<span class="token punctuation">;</span>                o<span class="token punctuation">.</span>pos <span class="token operator">=</span> <span class="token function">UnityObjectToClipPos</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>vertex<span class="token punctuation">)</span> <span class="token punctuation">;</span>                o<span class="token punctuation">.</span>normalDir <span class="token operator">=</span> <span class="token function">UnityObjectToWorldNormal</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>normal<span class="token punctuation">)</span><span class="token punctuation">;</span>                 o<span class="token punctuation">.</span>worldPos <span class="token operator">=</span> <span class="token function">mul</span><span class="token punctuation">(</span>unity_ObjectToWorld<span class="token punctuation">,</span>v<span class="token punctuation">.</span>vertex<span class="token punctuation">)</span><span class="token punctuation">.</span>xyz<span class="token punctuation">;</span>                <span class="token keyword">return</span> o<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            fixed4 <span class="token function">frag</span><span class="token punctuation">(</span> v2f v <span class="token punctuation">)</span><span class="token punctuation">:</span>COLOR            <span class="token punctuation">{</span>                float3 normal <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>normalDir<span class="token punctuation">)</span><span class="token punctuation">;</span>                float3 viewDir <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>_WorldSpaceCameraPos <span class="token operator">-</span> v<span class="token punctuation">.</span>worldPos<span class="token punctuation">)</span><span class="token punctuation">;</span>                float normalDotViewDir <span class="token operator">=</span> <span class="token function">saturate</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>normal<span class="token punctuation">,</span>viewDir<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                fixed3 diffuse <span class="token operator">=</span> normalDotViewDir <span class="token operator">*</span>_Color<span class="token punctuation">;</span>                  <span class="token keyword">return</span> <span class="token function">fixed4</span><span class="token punctuation">(</span>diffuse <span class="token operator">+</span> _RimColor <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> normalDotViewDir<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> _AlphaRange<span class="token punctuation">)</span> <span class="token operator">+</span> _AlphaRange<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            ENDCG        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    Fallback <span class="token string">"Diffuse"</span><span class="token punctuation">}</span></code></pre><h2 id="透明度混合"><a href="#透明度混合" class="headerlink" title="透明度混合"></a>透明度混合</h2><p>上一篇我们了解了透明度混合的原理以及一些透明度知识（<a href="http://chenwenling.cn/2017/11/18/Unity%20Shader%20%E5%85%A5%E9%97%A8%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/" target="_blank" rel="noopener">传送门</a>），而Unity中，为了进行透明度混合，我们需要用到【Blend】命令： </p><table><thead><tr><th style="text-align:center">语法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">Blend Off</td><td style="text-align:center">关闭混合（这是默认的状态）</td></tr><tr><td style="text-align:center">Blend SrcFactor DstFactor</td><td style="text-align:center">开启混合，该片元产生的颜色<em>SrcFactor. 已存在于屏幕的颜色 </em>DstFactor，然后将两者叠加在一起存入颜色缓冲。</td></tr><tr><td style="text-align:center">Blend SrcFactor DstFactor, SrcFactorA DstFactorA</td><td style="text-align:center">原理同上，不过使用了不同的混合因子</td></tr><tr><td style="text-align:center">BlendOp Op</td><td style="text-align:center">不同于上面的颜色混合，而是使用Blend Operation（<a href="https://docs.unity3d.com/Manual/SL-Blend.html" target="_blank" rel="noopener">传送门</a>）来对它们进行操作</td></tr><tr><td style="text-align:center">BlendOp OpColor, OpAlpha</td><td style="text-align:center">原理同上，不过采用不同的Blend Operation来操作Color和Alpha的通道</td></tr></tbody></table><p>混合因子：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">One</td><td style="text-align:center">因子为1，表示让源颜色或者目标颜色通过</td></tr><tr><td style="text-align:center">Zero</td><td style="text-align:center">因子为0，用来删除源颜色或者目标颜色</td></tr><tr><td style="text-align:center">SrcColor</td><td style="text-align:center">因子为源颜色</td></tr><tr><td style="text-align:center">SrcAlpha</td><td style="text-align:center">因子为源颜色的透明度</td></tr><tr><td style="text-align:center">DstColor</td><td style="text-align:center">因子为目标颜色</td></tr><tr><td style="text-align:center">DstAlpha</td><td style="text-align:center">因子为目标颜色的透明度</td></tr><tr><td style="text-align:center">OneMinusSrcColor</td><td style="text-align:center">因子为 (1 - 源颜色) 的值</td></tr><tr><td style="text-align:center">OneMinusSrcAlpha</td><td style="text-align:center">因子为 (1 - 源颜色的透明度) 的值</td></tr><tr><td style="text-align:center">OneMinusDstColor</td><td style="text-align:center">因子为 (1 - 目标颜色) 的值</td></tr><tr><td style="text-align:center">OneMinusDstAlpha</td><td style="text-align:center">因子为 (1 - 目标颜色的透明度) 的值</td></tr></tbody></table><p>此时我们再来看上面这一块代码：</p><pre class=" language-haxe"><code class="language-haxe">Tags<span class="token punctuation">{</span>         <span class="token string">"Queue"</span><span class="token operator">=</span><span class="token string">"Transparent"</span>        <span class="token string">"IgnoreProjector"</span><span class="token operator">=</span><span class="token string">"True"</span>        <span class="token string">"RenderType"</span><span class="token operator">=</span><span class="token string">"Transparent"</span> <span class="token punctuation">}</span>            ZWrite Off         Blend SrcAlpha OneMinusSrcAlpha         LOD <span class="token number">200</span></code></pre><ul><li>这里有一些新的知识：之前提过半透明物体的渲染序列要设置成<code>&quot;Queue&quot;=&quot;Transparent&quot;</code>,而<code>&quot;RenderType&quot;=&quot;Transparent&quot;</code>表示我们使用了透明度混合。通常一个半透明的Shader Tags都包含这三条：<pre class=" language-haxe"><code class="language-haxe">      <span class="token string">"Queue"</span><span class="token operator">=</span><span class="token string">"Transparent"</span>      <span class="token string">"IgnoreProjector"</span><span class="token operator">=</span><span class="token string">"True"</span>      <span class="token string">"RenderType"</span><span class="token operator">=</span><span class="token string">"Transparent"</span></code></pre></li><li>接下来是  <code>ZWrite Off</code> : 我们在上一篇介绍过为什么透明度混合需要关闭深度写入</li><li>最后是  <code>Blend SrcAlpha OneMinusSrcAlpha</code> : 这里我们将源颜色的混合因子设置成<code>SrcAlpha</code>，将目标颜色的混合因子设置成 <code>OneMinusSrcAlpha</code> 以得到半透明效果。</li></ul><h2 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h2><pre class=" language-haxe"><code class="language-haxe">            struct a2v            <span class="token punctuation">{</span>                float4 vertex <span class="token punctuation">:</span> POSITION<span class="token punctuation">;</span>                float3 normal <span class="token punctuation">:</span> NORMAL<span class="token punctuation">;</span>                         <span class="token punctuation">}</span><span class="token punctuation">;</span>            struct v2f            <span class="token punctuation">{</span>                float4 pos <span class="token punctuation">:</span> SV_POSITION<span class="token punctuation">;</span>                float3 normalDir <span class="token punctuation">:</span> TEXCOORD0<span class="token punctuation">;</span>                float3 worldPos <span class="token punctuation">:</span> TEXCOORD1<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h3 id="a2v-：包含顶点着色器要的模型数据"><a href="#a2v-：包含顶点着色器要的模型数据" class="headerlink" title="a2v ：包含顶点着色器要的模型数据"></a>a2v ：包含顶点着色器要的模型数据</h3><ul><li><code>float4 vertex : POSITION;</code>这一句表示：用模型顶点的坐标填充vertex变量。 </li><li><code>float3 normal : NORMAL;</code> 这一句表示：用模型空间的法线方向向量填充normal变量</li></ul><h3 id="v2f-：用于顶点着色器和片元着色器之间传递信息"><a href="#v2f-：用于顶点着色器和片元着色器之间传递信息" class="headerlink" title="v2f ：用于顶点着色器和片元着色器之间传递信息"></a>v2f ：用于顶点着色器和片元着色器之间传递信息</h3><ul><li><code>float4 pos : SV_POSITION;</code>这一句表示：用裁剪空间的位置信息填充pos变量</li><li><code>float3 normalDir : TEXCOORD0;</code>这一句表示：用模型的第一套纹理坐标填充normalDir变量</li><li><code>float3 worldPos : TEXCOORD1;</code>这一句表示：用模型的第二套纹理坐标填充worldPos变量</li></ul><h2 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h2><pre class=" language-haxe"><code class="language-haxe">            v2f <span class="token function">vert</span><span class="token punctuation">(</span> a2v v <span class="token punctuation">)</span>            <span class="token punctuation">{</span>                v2f o<span class="token punctuation">;</span>                o<span class="token punctuation">.</span>pos <span class="token operator">=</span> <span class="token function">UnityObjectToClipPos</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>vertex<span class="token punctuation">)</span><span class="token punctuation">;</span>                o<span class="token punctuation">.</span>normalDir <span class="token operator">=</span> <span class="token function">UnityObjectToWorldNormal</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>normal<span class="token punctuation">)</span><span class="token punctuation">;</span>                 o<span class="token punctuation">.</span>worldPos <span class="token operator">=</span> <span class="token function">mul</span><span class="token punctuation">(</span>unity_ObjectToWorld<span class="token punctuation">,</span>v<span class="token punctuation">.</span>vertex<span class="token punctuation">)</span><span class="token punctuation">.</span>xyz<span class="token punctuation">;</span>                <span class="token keyword">return</span> o<span class="token punctuation">;</span>            <span class="token punctuation">}</span></code></pre><ul><li><code>UnityObjectToClipPos(v.vertex)</code>是Unity5.6之后的写法，之前是<code>mul(UNITY_MATRIX_MVP,v.vertex)</code> 这一句的意思是:将模型空间的顶点信息转换到裁剪空间中的位置信息，然后将信息存储在o.pos中。</li><li><code>UnityObjectToWorldNormal(v.normal)</code>这一句的意思是:法线从模型空间变换到世界空间中并计算物体在世界空间中的法线坐标。</li><li><code>mul(unity_ObjectToWorld,v.vertex).xyz;</code>这一句的意思是：将顶点从模型空间转换到世界空间的信息存储到worldPos变量中。</li></ul><h2 id="片元着色器"><a href="#片元着色器" class="headerlink" title="片元着色器"></a>片元着色器</h2><pre class=" language-haxe"><code class="language-haxe">            fixed4 <span class="token function">frag</span><span class="token punctuation">(</span> v2f v <span class="token punctuation">)</span><span class="token punctuation">:</span>COLOR            <span class="token punctuation">{</span>                float3 normal <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>normalDir<span class="token punctuation">)</span><span class="token punctuation">;</span>                float3 viewDir <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>_WorldSpaceCameraPos <span class="token operator">-</span> v<span class="token punctuation">.</span>worldPos<span class="token punctuation">)</span><span class="token punctuation">;</span>                float normalDotViewDir <span class="token operator">=</span> <span class="token function">saturate</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>normal<span class="token punctuation">,</span>viewDir<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                fixed3 diffuse <span class="token operator">=</span> normalDotViewDir <span class="token operator">*</span>_Color<span class="token punctuation">;</span>                  <span class="token keyword">return</span> <span class="token function">fixed4</span><span class="token punctuation">(</span>diffuse <span class="token operator">+</span> _RimColor <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> normalDotViewDir<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> _AlphaRange<span class="token punctuation">)</span> <span class="token operator">+</span> _AlphaRange<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span></code></pre><ul><li><code>fixed4 frag( v2f v ):COLOR</code>  我们注意到片元着色器的后面跟着<code>:COLOR</code> ：这是Unity提供的Cg/HLSL语义。语义可以告诉shader数据的来源以及数据的输出。</li><li><code>float3 viewDir = normalize(_WorldSpaceCameraPos - v.worldPos);</code> 这里我们用<code>对象在世界坐标系中的位置</code>减去<code>摄像机的世界空间位置</code>，并进行逐顶点归一化，赋给视线的方向</li><li><code>float normalDotViewDir = saturate(dot(normal,viewDir))</code> 我们获得法线与视线的夹角</li><li><code>fixed3 diffuse = normalDotViewDir *_Color;</code> 这里我们视线与法线的夹角和主颜色相乘。</li><li><code>return fixed4(diffuse + _RimColor ,(1 - normalDotViewDir) * (1 - _AlphaRange) + _AlphaRange);</code> 最后将混合后的颜色输出。</li></ul>]]></content>
=======
        <content type="html"><![CDATA[<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>之前我们写过一个边缘发光的Shader（<a href="http://chenwenling.cn/2017/11/13/Unity%20Shader%20%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAShader/" target="_blank" rel="noopener">传送门</a>），这一次我们来写这个的升级版：透明物体的边缘发光。</p><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p>首先我们还是来看一下效果图：<br><img src="https://github.com/kurong00/blog/blob/master/thumbnail/shader5/RimEnerge.PNG?raw=true" alt></p><h2 id="Shader代码"><a href="#Shader代码" class="headerlink" title="Shader代码"></a>Shader代码</h2><pre class=" language-haxe"><code class="language-haxe">Shader <span class="token string">"Custom/Rim/RimEnerge"</span> <span class="token punctuation">{</span>    Properties    <span class="token punctuation">{</span>        <span class="token function">_Color</span><span class="token punctuation">(</span><span class="token string">"Main Color"</span><span class="token punctuation">,</span>Color<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0.6</span><span class="token punctuation">,</span><span class="token number">0.6</span><span class="token punctuation">,</span><span class="token number">0.6</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token function">_AlphaRange</span><span class="token punctuation">(</span><span class="token string">"Alpha Range"</span><span class="token punctuation">,</span><span class="token function">Range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span>        <span class="token function">_RimColor</span><span class="token punctuation">(</span><span class="token string">"Rim Color"</span><span class="token punctuation">,</span>Color<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    SubShader    <span class="token punctuation">{</span>        Tags<span class="token punctuation">{</span>             <span class="token string">"Queue"</span><span class="token operator">=</span><span class="token string">"Transparent"</span>            <span class="token string">"IgnoreProjector"</span><span class="token operator">=</span><span class="token string">"True"</span>            <span class="token string">"RenderType"</span><span class="token operator">=</span><span class="token string">"Transparent"</span> <span class="token punctuation">}</span>            ZWrite Off         Blend SrcAlpha OneMinusSrcAlpha         LOD <span class="token number">200</span>                 Pass        <span class="token punctuation">{</span>            CGPROGRAM            <span class="token preprocessor builtin">#pragma</span> vertex vert            <span class="token preprocessor builtin">#pragma</span> fragment frag            <span class="token preprocessor builtin">#include</span> <span class="token string">"Lighting.cginc"</span>                  struct a2v            <span class="token punctuation">{</span>                float4 vertex <span class="token punctuation">:</span> POSITION<span class="token punctuation">;</span>                float3 normal <span class="token punctuation">:</span> NORMAL<span class="token punctuation">;</span>                         <span class="token punctuation">}</span><span class="token punctuation">;</span>            struct v2f            <span class="token punctuation">{</span>                float4 pos <span class="token punctuation">:</span> SV_POSITION<span class="token punctuation">;</span>                float3 normalDir <span class="token punctuation">:</span> TEXCOORD0<span class="token punctuation">;</span>                float3 worldPos <span class="token punctuation">:</span> TEXCOORD1<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span>            fixed4 _Color<span class="token punctuation">;</span>            float _AlphaRange<span class="token punctuation">;</span>            fixed4 _RimColor<span class="token punctuation">;</span>            v2f <span class="token function">vert</span><span class="token punctuation">(</span> a2v v <span class="token punctuation">)</span>            <span class="token punctuation">{</span>                v2f o<span class="token punctuation">;</span>                o<span class="token punctuation">.</span>pos <span class="token operator">=</span> <span class="token function">UnityObjectToClipPos</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>vertex<span class="token punctuation">)</span> <span class="token punctuation">;</span>                o<span class="token punctuation">.</span>normalDir <span class="token operator">=</span> <span class="token function">UnityObjectToWorldNormal</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>normal<span class="token punctuation">)</span><span class="token punctuation">;</span>                 o<span class="token punctuation">.</span>worldPos <span class="token operator">=</span> <span class="token function">mul</span><span class="token punctuation">(</span>unity_ObjectToWorld<span class="token punctuation">,</span>v<span class="token punctuation">.</span>vertex<span class="token punctuation">)</span><span class="token punctuation">.</span>xyz<span class="token punctuation">;</span>                <span class="token keyword">return</span> o<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            fixed4 <span class="token function">frag</span><span class="token punctuation">(</span> v2f v <span class="token punctuation">)</span><span class="token punctuation">:</span>COLOR            <span class="token punctuation">{</span>                float3 normal <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>normalDir<span class="token punctuation">)</span><span class="token punctuation">;</span>                float3 viewDir <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>_WorldSpaceCameraPos <span class="token operator">-</span> v<span class="token punctuation">.</span>worldPos<span class="token punctuation">)</span><span class="token punctuation">;</span>                float normalDotViewDir <span class="token operator">=</span> <span class="token function">saturate</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>normal<span class="token punctuation">,</span>viewDir<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                fixed3 diffuse <span class="token operator">=</span> normalDotViewDir <span class="token operator">*</span>_Color<span class="token punctuation">;</span>                  <span class="token keyword">return</span> <span class="token function">fixed4</span><span class="token punctuation">(</span>diffuse <span class="token operator">+</span> _RimColor <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> normalDotViewDir<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> _AlphaRange<span class="token punctuation">)</span> <span class="token operator">+</span> _AlphaRange<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            ENDCG        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    Fallback <span class="token string">"Diffuse"</span><span class="token punctuation">}</span></code></pre><h2 id="透明度混合"><a href="#透明度混合" class="headerlink" title="透明度混合"></a>透明度混合</h2><p>上一篇我们了解了透明度混合的原理以及一些透明度知识（<a href="http://chenwenling.cn/2017/11/18/Unity%20Shader%20%E5%85%A5%E9%97%A8%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/" target="_blank" rel="noopener">传送门</a>），而Unity中，为了进行透明度混合，我们需要用到【Blend】命令： </p><table><thead><tr><th style="text-align:center">语法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">Blend Off</td><td style="text-align:center">关闭混合（这是默认的状态）</td></tr><tr><td style="text-align:center">Blend SrcFactor DstFactor</td><td style="text-align:center">开启混合，该片元产生的颜色<em>SrcFactor. 已存在于屏幕的颜色 </em>DstFactor，然后将两者叠加在一起存入颜色缓冲。</td></tr><tr><td style="text-align:center">Blend SrcFactor DstFactor, SrcFactorA DstFactorA</td><td style="text-align:center">原理同上，不过使用了不同的混合因子</td></tr><tr><td style="text-align:center">BlendOp Op</td><td style="text-align:center">不同于上面的颜色混合，而是使用Blend Operation（<a href="https://docs.unity3d.com/Manual/SL-Blend.html" target="_blank" rel="noopener">传送门</a>）来对它们进行操作</td></tr><tr><td style="text-align:center">BlendOp OpColor, OpAlpha</td><td style="text-align:center">原理同上，不过采用不同的Blend Operation来操作Color和Alpha的通道</td></tr></tbody></table><p>混合因子：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">One</td><td style="text-align:center">因子为1，表示让源颜色或者目标颜色通过</td></tr><tr><td style="text-align:center">Zero</td><td style="text-align:center">因子为0，用来删除源颜色或者目标颜色</td></tr><tr><td style="text-align:center">SrcColor</td><td style="text-align:center">因子为源颜色</td></tr><tr><td style="text-align:center">SrcAlpha</td><td style="text-align:center">因子为源颜色的透明度</td></tr><tr><td style="text-align:center">DstColor</td><td style="text-align:center">因子为目标颜色</td></tr><tr><td style="text-align:center">DstAlpha</td><td style="text-align:center">因子为目标颜色的透明度</td></tr><tr><td style="text-align:center">OneMinusSrcColor</td><td style="text-align:center">因子为 (1 - 源颜色) 的值</td></tr><tr><td style="text-align:center">OneMinusSrcAlpha</td><td style="text-align:center">因子为 (1 - 源颜色的透明度) 的值</td></tr><tr><td style="text-align:center">OneMinusDstColor</td><td style="text-align:center">因子为 (1 - 目标颜色) 的值</td></tr><tr><td style="text-align:center">OneMinusDstAlpha</td><td style="text-align:center">因子为 (1 - 目标颜色的透明度) 的值</td></tr></tbody></table><p>此时我们再来看上面这一块代码：</p><pre class=" language-haxe"><code class="language-haxe">Tags<span class="token punctuation">{</span>         <span class="token string">"Queue"</span><span class="token operator">=</span><span class="token string">"Transparent"</span>        <span class="token string">"IgnoreProjector"</span><span class="token operator">=</span><span class="token string">"True"</span>        <span class="token string">"RenderType"</span><span class="token operator">=</span><span class="token string">"Transparent"</span> <span class="token punctuation">}</span>            ZWrite Off         Blend SrcAlpha OneMinusSrcAlpha         LOD <span class="token number">200</span>    </code></pre><ul><li>这里有一些新的知识：之前提过半透明物体的渲染序列要设置成<code>&quot;Queue&quot;=&quot;Transparent&quot;</code>,而<code>&quot;RenderType&quot;=&quot;Transparent&quot;</code>表示我们使用了透明度混合。通常一个半透明的Shader Tags都包含这三条：<pre class=" language-haxe"><code class="language-haxe">      <span class="token string">"Queue"</span><span class="token operator">=</span><span class="token string">"Transparent"</span>      <span class="token string">"IgnoreProjector"</span><span class="token operator">=</span><span class="token string">"True"</span>      <span class="token string">"RenderType"</span><span class="token operator">=</span><span class="token string">"Transparent"</span></code></pre></li><li>接下来是  <code>ZWrite Off</code> : 我们在上一篇介绍过为什么透明度混合需要关闭深度写入</li><li>最后是  <code>Blend SrcAlpha OneMinusSrcAlpha</code> : 这里我们将源颜色的混合因子设置成<code>SrcAlpha</code>，将目标颜色的混合因子设置成 <code>OneMinusSrcAlpha</code> 以得到半透明效果。</li></ul><h2 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h2><pre class=" language-haxe"><code class="language-haxe">            struct a2v            <span class="token punctuation">{</span>                float4 vertex <span class="token punctuation">:</span> POSITION<span class="token punctuation">;</span>                float3 normal <span class="token punctuation">:</span> NORMAL<span class="token punctuation">;</span>                         <span class="token punctuation">}</span><span class="token punctuation">;</span>            struct v2f            <span class="token punctuation">{</span>                float4 pos <span class="token punctuation">:</span> SV_POSITION<span class="token punctuation">;</span>                float3 normalDir <span class="token punctuation">:</span> TEXCOORD0<span class="token punctuation">;</span>                float3 worldPos <span class="token punctuation">:</span> TEXCOORD1<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h3 id="a2v-：包含顶点着色器要的模型数据"><a href="#a2v-：包含顶点着色器要的模型数据" class="headerlink" title="a2v ：包含顶点着色器要的模型数据"></a>a2v ：包含顶点着色器要的模型数据</h3><ul><li><code>float4 vertex : POSITION;</code>这一句表示：用模型顶点的坐标填充vertex变量。 </li><li><code>float3 normal : NORMAL;</code> 这一句表示：用模型空间的法线方向向量填充normal变量</li></ul><h3 id="v2f-：用于顶点着色器和片元着色器之间传递信息"><a href="#v2f-：用于顶点着色器和片元着色器之间传递信息" class="headerlink" title="v2f ：用于顶点着色器和片元着色器之间传递信息"></a>v2f ：用于顶点着色器和片元着色器之间传递信息</h3><ul><li><code>float4 pos : SV_POSITION;</code>这一句表示：用裁剪空间的位置信息填充pos变量</li><li><code>float3 normalDir : TEXCOORD0;</code>这一句表示：用模型的第一套纹理坐标填充normalDir变量</li><li><code>float3 worldPos : TEXCOORD1;</code>这一句表示：用模型的第二套纹理坐标填充worldPos变量</li></ul><h2 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h2><pre class=" language-haxe"><code class="language-haxe">            v2f <span class="token function">vert</span><span class="token punctuation">(</span> a2v v <span class="token punctuation">)</span>            <span class="token punctuation">{</span>                v2f o<span class="token punctuation">;</span>                o<span class="token punctuation">.</span>pos <span class="token operator">=</span> <span class="token function">UnityObjectToClipPos</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>vertex<span class="token punctuation">)</span><span class="token punctuation">;</span>                o<span class="token punctuation">.</span>normalDir <span class="token operator">=</span> <span class="token function">UnityObjectToWorldNormal</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>normal<span class="token punctuation">)</span><span class="token punctuation">;</span>                 o<span class="token punctuation">.</span>worldPos <span class="token operator">=</span> <span class="token function">mul</span><span class="token punctuation">(</span>unity_ObjectToWorld<span class="token punctuation">,</span>v<span class="token punctuation">.</span>vertex<span class="token punctuation">)</span><span class="token punctuation">.</span>xyz<span class="token punctuation">;</span>                <span class="token keyword">return</span> o<span class="token punctuation">;</span>            <span class="token punctuation">}</span></code></pre><ul><li><code>UnityObjectToClipPos(v.vertex)</code>是Unity5.6之后的写法，之前是<code>mul(UNITY_MATRIX_MVP,v.vertex)</code> 这一句的意思是:将模型空间的顶点信息转换到裁剪空间中的位置信息，然后将信息存储在o.pos中。</li><li><code>UnityObjectToWorldNormal(v.normal)</code>这一句的意思是:法线从模型空间变换到世界空间中并计算物体在世界空间中的法线坐标。</li><li><code>mul(unity_ObjectToWorld,v.vertex).xyz;</code>这一句的意思是：将顶点从模型空间转换到世界空间的信息存储到worldPos变量中。</li></ul><h2 id="片元着色器"><a href="#片元着色器" class="headerlink" title="片元着色器"></a>片元着色器</h2><pre class=" language-haxe"><code class="language-haxe">            fixed4 <span class="token function">frag</span><span class="token punctuation">(</span> v2f v <span class="token punctuation">)</span><span class="token punctuation">:</span>COLOR            <span class="token punctuation">{</span>                float3 normal <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span>normalDir<span class="token punctuation">)</span><span class="token punctuation">;</span>                float3 viewDir <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>_WorldSpaceCameraPos <span class="token operator">-</span> v<span class="token punctuation">.</span>worldPos<span class="token punctuation">)</span><span class="token punctuation">;</span>                float normalDotViewDir <span class="token operator">=</span> <span class="token function">saturate</span><span class="token punctuation">(</span><span class="token function">dot</span><span class="token punctuation">(</span>normal<span class="token punctuation">,</span>viewDir<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                fixed3 diffuse <span class="token operator">=</span> normalDotViewDir <span class="token operator">*</span>_Color<span class="token punctuation">;</span>                  <span class="token keyword">return</span> <span class="token function">fixed4</span><span class="token punctuation">(</span>diffuse <span class="token operator">+</span> _RimColor <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> normalDotViewDir<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> _AlphaRange<span class="token punctuation">)</span> <span class="token operator">+</span> _AlphaRange<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span></code></pre><ul><li><code>fixed4 frag( v2f v ):COLOR</code>  我们注意到片元着色器的后面跟着<code>:COLOR</code> ：这是Unity提供的Cg/HLSL语义。语义可以告诉shader数据的来源以及数据的输出。</li><li><code>float3 viewDir = normalize(_WorldSpaceCameraPos - v.worldPos);</code> 这里我们用<code>对象在世界坐标系中的位置</code>减去<code>摄像机的世界空间位置</code>，并进行逐顶点归一化，赋给视线的方向</li><li><code>float normalDotViewDir = saturate(dot(normal,viewDir))</code> 我们获得法线与视线的夹角</li><li><code>fixed3 diffuse = normalDotViewDir *_Color;</code> 这里我们视线与法线的夹角和主颜色相乘。</li><li><code>return fixed4(diffuse + _RimColor ,(1 - normalDotViewDir) * (1 - _AlphaRange) + _AlphaRange);</code> 最后将混合后的颜色输出。</li></ul>]]></content>
>>>>>>> 9e62def5d865150fae5440cc55e3c06c4faf11a3
=======
        <content type="html"><![CDATA[<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>之前我们写过一个边缘发光的Shader（<a href="http://chenwenling.cn/2017/11/13/Unity%20Shader%20%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAShader/" target="_blank" rel="noopener">传送门</a>），这一次我们来写这个的升级版：透明物体的边缘发光。</p><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p>首先我们还是来看一下效果图：<br><img src="https://github.com/kurong00/blog/blob/master/thumbnail/shader5/RimEnerge.PNG?raw=true" alt></p><h2 id="Shader代码"><a href="#Shader代码" class="headerlink" title="Shader代码"></a>Shader代码</h2><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="hljs-string">"Custom/Rim/RimEnerge"</span> &#123;</span><br><span class="line">Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color(<span class="hljs-string">"Main Color"</span>,Color) = (<span class="hljs-number">0.6</span>,<span class="hljs-number">0.6</span>,<span class="hljs-number">0.6</span>,<span class="hljs-number">1</span>)</span><br><span class="line">        _AlphaRange(<span class="hljs-string">"Alpha Range"</span>,Range(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)) = <span class="hljs-number">0</span></span><br><span class="line">        _RimColor(<span class="hljs-string">"Rim Color"</span>,Color) = (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags&#123; </span><br><span class="line"><span class="hljs-string">"Queue"</span>=<span class="hljs-string">"Transparent"</span></span><br><span class="line"><span class="hljs-string">"IgnoreProjector"</span>=<span class="hljs-string">"True"</span></span><br><span class="line"><span class="hljs-string">"RenderType"</span>=<span class="hljs-string">"Transparent"</span> &#125;    </span><br><span class="line">ZWrite Off </span><br><span class="line">Blend SrcAlpha OneMinusSrcAlpha </span><br><span class="line">        LOD <span class="hljs-number">200</span>         </span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="hljs-meta">#pragma vertex vert</span></span><br><span class="line">            <span class="hljs-meta">#pragma fragment frag</span></span><br><span class="line"><span class="hljs-meta">#include "Lighting.cginc"      </span></span><br><span class="line"></span><br><span class="line">            struct a2v</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : <span class="hljs-type">POSITION</span>;</span><br><span class="line">                float3 normal : <span class="hljs-type">NORMAL</span>;             </span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : <span class="hljs-type">SV_POSITION</span>;</span><br><span class="line">                float3 normalDir : <span class="hljs-type">TEXCOORD0</span>;</span><br><span class="line">                float3 worldPos : <span class="hljs-type">TEXCOORD1</span>;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            float _AlphaRange;</span><br><span class="line">            fixed4 _RimColor;</span><br><span class="line"></span><br><span class="line">            v2f vert( a2v v )</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex) ;</span><br><span class="line">                o.normalDir = UnityObjectToWorldNormal(v.normal); </span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">                <span class="hljs-keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag( v2f v ):<span class="hljs-type">COLOR</span></span><br><span class="line"><span class="hljs-type">            </span>&#123;</span><br><span class="line">                float3 normal = normalize(v.normalDir);</span><br><span class="line">                float3 viewDir = normalize(_WorldSpaceCameraPos - v.worldPos);</span><br><span class="line">                float normalDotViewDir = saturate(dot(normal,viewDir));</span><br><span class="line">fixed3 diffuse = normalDotViewDir *_Color;  </span><br><span class="line">                <span class="hljs-keyword">return</span> fixed4(diffuse + _RimColor ,(<span class="hljs-number">1</span> - normalDotViewDir) * (<span class="hljs-number">1</span> - _AlphaRange) + _AlphaRange);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="hljs-string">"Diffuse"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="透明度混合"><a href="#透明度混合" class="headerlink" title="透明度混合"></a>透明度混合</h2><p>上一篇我们了解了透明度混合的原理以及一些透明度知识（<a href="http://chenwenling.cn/2017/11/18/Unity%20Shader%20%E5%85%A5%E9%97%A8%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/" target="_blank" rel="noopener">传送门</a>），而Unity中，为了进行透明度混合，我们需要用到【Blend】命令： </p><table><thead><tr><th style="text-align:center">语法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">Blend Off</td><td style="text-align:center">关闭混合（这是默认的状态）</td></tr><tr><td style="text-align:center">Blend SrcFactor DstFactor</td><td style="text-align:center">开启混合，该片元产生的颜色<em>SrcFactor. 已存在于屏幕的颜色 </em>DstFactor，然后将两者叠加在一起存入颜色缓冲。</td></tr><tr><td style="text-align:center">Blend SrcFactor DstFactor, SrcFactorA DstFactorA</td><td style="text-align:center">原理同上，不过使用了不同的混合因子</td></tr><tr><td style="text-align:center">BlendOp Op</td><td style="text-align:center">不同于上面的颜色混合，而是使用Blend Operation（<a href="https://docs.unity3d.com/Manual/SL-Blend.html" target="_blank" rel="noopener">传送门</a>）来对它们进行操作</td></tr><tr><td style="text-align:center">BlendOp OpColor, OpAlpha</td><td style="text-align:center">原理同上，不过采用不同的Blend Operation来操作Color和Alpha的通道</td></tr></tbody></table><p>混合因子：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">One</td><td style="text-align:center">因子为1，表示让源颜色或者目标颜色通过</td></tr><tr><td style="text-align:center">Zero</td><td style="text-align:center">因子为0，用来删除源颜色或者目标颜色</td></tr><tr><td style="text-align:center">SrcColor</td><td style="text-align:center">因子为源颜色</td></tr><tr><td style="text-align:center">SrcAlpha</td><td style="text-align:center">因子为源颜色的透明度</td></tr><tr><td style="text-align:center">DstColor</td><td style="text-align:center">因子为目标颜色</td></tr><tr><td style="text-align:center">DstAlpha</td><td style="text-align:center">因子为目标颜色的透明度</td></tr><tr><td style="text-align:center">OneMinusSrcColor</td><td style="text-align:center">因子为 (1 - 源颜色) 的值</td></tr><tr><td style="text-align:center">OneMinusSrcAlpha</td><td style="text-align:center">因子为 (1 - 源颜色的透明度) 的值</td></tr><tr><td style="text-align:center">OneMinusDstColor</td><td style="text-align:center">因子为 (1 - 目标颜色) 的值</td></tr><tr><td style="text-align:center">OneMinusDstAlpha</td><td style="text-align:center">因子为 (1 - 目标颜色的透明度) 的值</td></tr></tbody></table><p>此时我们再来看上面这一块代码：<br><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Tags&#123; </span><br><span class="line"><span class="hljs-string">"Queue"</span>=<span class="hljs-string">"Transparent"</span></span><br><span class="line"><span class="hljs-string">"IgnoreProjector"</span>=<span class="hljs-string">"True"</span></span><br><span class="line"><span class="hljs-string">"RenderType"</span>=<span class="hljs-string">"Transparent"</span> &#125;    </span><br><span class="line">ZWrite Off </span><br><span class="line">Blend SrcAlpha OneMinusSrcAlpha </span><br><span class="line">        LOD <span class="hljs-number">200</span></span><br></pre></td></tr></table></figure></p><ul><li><p>这里有一些新的知识：之前提过半透明物体的渲染序列要设置成<code>&quot;Queue&quot;=&quot;Transparent&quot;</code>,而<code>&quot;RenderType&quot;=&quot;Transparent&quot;</code>表示我们使用了透明度混合。通常一个半透明的Shader Tags都包含这三条：</p><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">"Queue"</span>=<span class="hljs-string">"Transparent"</span></span><br><span class="line"><span class="hljs-string">"IgnoreProjector"</span>=<span class="hljs-string">"True"</span></span><br><span class="line"><span class="hljs-string">"RenderType"</span>=<span class="hljs-string">"Transparent"</span></span><br></pre></td></tr></table></figure></li><li><p>接下来是  <code>ZWrite Off</code> : 我们在上一篇介绍过为什么透明度混合需要关闭深度写入</p></li><li>最后是  <code>Blend SrcAlpha OneMinusSrcAlpha</code> : 这里我们将源颜色的混合因子设置成<code>SrcAlpha</code>，将目标颜色的混合因子设置成 <code>OneMinusSrcAlpha</code> 以得到半透明效果。</li></ul><h2 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h2><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct a2v</span><br><span class="line">&#123;</span><br><span class="line">    float4 vertex : <span class="hljs-type">POSITION</span>;</span><br><span class="line">    float3 normal : <span class="hljs-type">NORMAL</span>;             </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct v2f</span><br><span class="line">&#123;</span><br><span class="line">    float4 pos : <span class="hljs-type">SV_POSITION</span>;</span><br><span class="line">    float3 normalDir : <span class="hljs-type">TEXCOORD0</span>;</span><br><span class="line">    float3 worldPos : <span class="hljs-type">TEXCOORD1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="a2v-：包含顶点着色器要的模型数据"><a href="#a2v-：包含顶点着色器要的模型数据" class="headerlink" title="a2v ：包含顶点着色器要的模型数据"></a>a2v ：包含顶点着色器要的模型数据</h3><ul><li><code>float4 vertex : POSITION;</code>这一句表示：用模型顶点的坐标填充vertex变量。 </li><li><code>float3 normal : NORMAL;</code> 这一句表示：用模型空间的法线方向向量填充normal变量</li></ul><h3 id="v2f-：用于顶点着色器和片元着色器之间传递信息"><a href="#v2f-：用于顶点着色器和片元着色器之间传递信息" class="headerlink" title="v2f ：用于顶点着色器和片元着色器之间传递信息"></a>v2f ：用于顶点着色器和片元着色器之间传递信息</h3><ul><li><code>float4 pos : SV_POSITION;</code>这一句表示：用裁剪空间的位置信息填充pos变量</li><li><code>float3 normalDir : TEXCOORD0;</code>这一句表示：用模型的第一套纹理坐标填充normalDir变量</li><li><code>float3 worldPos : TEXCOORD1;</code>这一句表示：用模型的第二套纹理坐标填充worldPos变量</li></ul><h2 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h2><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">v2f vert( a2v v )</span><br><span class="line">&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.normalDir = UnityObjectToWorldNormal(v.normal); </span><br><span class="line">    o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">    <span class="hljs-keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>UnityObjectToClipPos(v.vertex)</code>是Unity5.6之后的写法，之前是<code>mul(UNITY_MATRIX_MVP,v.vertex)</code> 这一句的意思是:将模型空间的顶点信息转换到裁剪空间中的位置信息，然后将信息存储在o.pos中。</li><li><code>UnityObjectToWorldNormal(v.normal)</code>这一句的意思是:法线从模型空间变换到世界空间中并计算物体在世界空间中的法线坐标。</li><li><code>mul(unity_ObjectToWorld,v.vertex).xyz;</code>这一句的意思是：将顶点从模型空间转换到世界空间的信息存储到worldPos变量中。</li></ul><h2 id="片元着色器"><a href="#片元着色器" class="headerlink" title="片元着色器"></a>片元着色器</h2><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        fixed4 frag( v2f v ):<span class="hljs-type">COLOR</span></span><br><span class="line"><span class="hljs-type">        </span>&#123;</span><br><span class="line">            float3 normal = normalize(v.normalDir);</span><br><span class="line">            float3 viewDir = normalize(_WorldSpaceCameraPos - v.worldPos);</span><br><span class="line">            float normalDotViewDir = saturate(dot(normal,viewDir));</span><br><span class="line">fixed3 diffuse = normalDotViewDir *_Color;  </span><br><span class="line">            <span class="hljs-keyword">return</span> fixed4(diffuse + _RimColor ,(<span class="hljs-number">1</span> - normalDotViewDir) * (<span class="hljs-number">1</span> - _AlphaRange) + _AlphaRange);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li><code>fixed4 frag( v2f v ):COLOR</code>  我们注意到片元着色器的后面跟着<code>:COLOR</code> ：这是Unity提供的Cg/HLSL语义。语义可以告诉shader数据的来源以及数据的输出。</li><li><code>float3 viewDir = normalize(_WorldSpaceCameraPos - v.worldPos);</code> 这里我们用<code>对象在世界坐标系中的位置</code>减去<code>摄像机的世界空间位置</code>，并进行逐顶点归一化，赋给视线的方向</li><li><code>float normalDotViewDir = saturate(dot(normal,viewDir))</code> 我们获得法线与视线的夹角</li><li><code>fixed3 diffuse = normalDotViewDir *_Color;</code> 这里我们视线与法线的夹角和主颜色相乘。</li><li><code>return fixed4(diffuse + _RimColor ,(1 - normalDotViewDir) * (1 - _AlphaRange) + _AlphaRange);</code> 最后将混合后的颜色输出。</li></ul>]]></content>
>>>>>>> 80f1222c4181d37c90be6af06b9c04e3d98c9327
=======
        <content type="html"><![CDATA[<h2><span id="导语">导语</span></h2><p>之前我们写过一个边缘发光的Shader（<a href="http://chenwenling.cn/2017/11/13/Unity%20Shader%20%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAShader/" target="_blank" rel="noopener">传送门</a>），这一次我们来写这个的升级版：透明物体的边缘发光。</p><h2><span id="效果图">效果图</span></h2><p>首先我们还是来看一下效果图：<br><img src="https://github.com/kurong00/blog/blob/master/thumbnail/shader5/RimEnerge.PNG?raw=true" alt></p><h2><span id="shader代码">Shader代码</span></h2><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="hljs-string">"Custom/Rim/RimEnerge"</span> &#123;</span><br><span class="line">Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color(<span class="hljs-string">"Main Color"</span>,Color) = (<span class="hljs-number">0.6</span>,<span class="hljs-number">0.6</span>,<span class="hljs-number">0.6</span>,<span class="hljs-number">1</span>)</span><br><span class="line">        _AlphaRange(<span class="hljs-string">"Alpha Range"</span>,Range(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)) = <span class="hljs-number">0</span></span><br><span class="line">        _RimColor(<span class="hljs-string">"Rim Color"</span>,Color) = (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags&#123; </span><br><span class="line"><span class="hljs-string">"Queue"</span>=<span class="hljs-string">"Transparent"</span></span><br><span class="line"><span class="hljs-string">"IgnoreProjector"</span>=<span class="hljs-string">"True"</span></span><br><span class="line"><span class="hljs-string">"RenderType"</span>=<span class="hljs-string">"Transparent"</span> &#125;    </span><br><span class="line">ZWrite Off </span><br><span class="line">Blend SrcAlpha OneMinusSrcAlpha </span><br><span class="line">        LOD <span class="hljs-number">200</span>         </span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="hljs-meta">#pragma vertex vert</span></span><br><span class="line">            <span class="hljs-meta">#pragma fragment frag</span></span><br><span class="line"><span class="hljs-meta">#include "Lighting.cginc"      </span></span><br><span class="line"></span><br><span class="line">            struct a2v</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : <span class="hljs-type">POSITION</span>;</span><br><span class="line">                float3 normal : <span class="hljs-type">NORMAL</span>;             </span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : <span class="hljs-type">SV_POSITION</span>;</span><br><span class="line">                float3 normalDir : <span class="hljs-type">TEXCOORD0</span>;</span><br><span class="line">                float3 worldPos : <span class="hljs-type">TEXCOORD1</span>;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            float _AlphaRange;</span><br><span class="line">            fixed4 _RimColor;</span><br><span class="line"></span><br><span class="line">            v2f vert( a2v v )</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex) ;</span><br><span class="line">                o.normalDir = UnityObjectToWorldNormal(v.normal); </span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">                <span class="hljs-keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag( v2f v ):<span class="hljs-type">COLOR</span></span><br><span class="line"><span class="hljs-type">            </span>&#123;</span><br><span class="line">                float3 normal = normalize(v.normalDir);</span><br><span class="line">                float3 viewDir = normalize(_WorldSpaceCameraPos - v.worldPos);</span><br><span class="line">                float normalDotViewDir = saturate(dot(normal,viewDir));</span><br><span class="line">fixed3 diffuse = normalDotViewDir *_Color;  </span><br><span class="line">                <span class="hljs-keyword">return</span> fixed4(diffuse + _RimColor ,(<span class="hljs-number">1</span> - normalDotViewDir) * (<span class="hljs-number">1</span> - _AlphaRange) + _AlphaRange);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="hljs-string">"Diffuse"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="透明度混合">透明度混合</span></h2><p>上一篇我们了解了透明度混合的原理以及一些透明度知识（<a href="http://chenwenling.cn/2017/11/18/Unity%20Shader%20%E5%85%A5%E9%97%A8%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/" target="_blank" rel="noopener">传送门</a>），而Unity中，为了进行透明度混合，我们需要用到【Blend】命令： </p><table><thead><tr><th style="text-align:center">语法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">Blend Off</td><td style="text-align:center">关闭混合（这是默认的状态）</td></tr><tr><td style="text-align:center">Blend SrcFactor DstFactor</td><td style="text-align:center">开启混合，该片元产生的颜色<em>SrcFactor. 已存在于屏幕的颜色 </em>DstFactor，然后将两者叠加在一起存入颜色缓冲。</td></tr><tr><td style="text-align:center">Blend SrcFactor DstFactor, SrcFactorA DstFactorA</td><td style="text-align:center">原理同上，不过使用了不同的混合因子</td></tr><tr><td style="text-align:center">BlendOp Op</td><td style="text-align:center">不同于上面的颜色混合，而是使用Blend Operation（<a href="https://docs.unity3d.com/Manual/SL-Blend.html" target="_blank" rel="noopener">传送门</a>）来对它们进行操作</td></tr><tr><td style="text-align:center">BlendOp OpColor, OpAlpha</td><td style="text-align:center">原理同上，不过采用不同的Blend Operation来操作Color和Alpha的通道</td></tr></tbody></table><p>混合因子：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">One</td><td style="text-align:center">因子为1，表示让源颜色或者目标颜色通过</td></tr><tr><td style="text-align:center">Zero</td><td style="text-align:center">因子为0，用来删除源颜色或者目标颜色</td></tr><tr><td style="text-align:center">SrcColor</td><td style="text-align:center">因子为源颜色</td></tr><tr><td style="text-align:center">SrcAlpha</td><td style="text-align:center">因子为源颜色的透明度</td></tr><tr><td style="text-align:center">DstColor</td><td style="text-align:center">因子为目标颜色</td></tr><tr><td style="text-align:center">DstAlpha</td><td style="text-align:center">因子为目标颜色的透明度</td></tr><tr><td style="text-align:center">OneMinusSrcColor</td><td style="text-align:center">因子为 (1 - 源颜色) 的值</td></tr><tr><td style="text-align:center">OneMinusSrcAlpha</td><td style="text-align:center">因子为 (1 - 源颜色的透明度) 的值</td></tr><tr><td style="text-align:center">OneMinusDstColor</td><td style="text-align:center">因子为 (1 - 目标颜色) 的值</td></tr><tr><td style="text-align:center">OneMinusDstAlpha</td><td style="text-align:center">因子为 (1 - 目标颜色的透明度) 的值</td></tr></tbody></table><p>此时我们再来看上面这一块代码：<br><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Tags&#123; </span><br><span class="line"><span class="hljs-string">"Queue"</span>=<span class="hljs-string">"Transparent"</span></span><br><span class="line"><span class="hljs-string">"IgnoreProjector"</span>=<span class="hljs-string">"True"</span></span><br><span class="line"><span class="hljs-string">"RenderType"</span>=<span class="hljs-string">"Transparent"</span> &#125;    </span><br><span class="line">ZWrite Off </span><br><span class="line">Blend SrcAlpha OneMinusSrcAlpha </span><br><span class="line">        LOD <span class="hljs-number">200</span></span><br></pre></td></tr></table></figure></p><ul><li><p>这里有一些新的知识：之前提过半透明物体的渲染序列要设置成<code>&quot;Queue&quot;=&quot;Transparent&quot;</code>,而<code>&quot;RenderType&quot;=&quot;Transparent&quot;</code>表示我们使用了透明度混合。通常一个半透明的Shader Tags都包含这三条：</p><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">"Queue"</span>=<span class="hljs-string">"Transparent"</span></span><br><span class="line"><span class="hljs-string">"IgnoreProjector"</span>=<span class="hljs-string">"True"</span></span><br><span class="line"><span class="hljs-string">"RenderType"</span>=<span class="hljs-string">"Transparent"</span></span><br></pre></td></tr></table></figure></li><li><p>接下来是  <code>ZWrite Off</code> : 我们在上一篇介绍过为什么透明度混合需要关闭深度写入</p></li><li>最后是  <code>Blend SrcAlpha OneMinusSrcAlpha</code> : 这里我们将源颜色的混合因子设置成<code>SrcAlpha</code>，将目标颜色的混合因子设置成 <code>OneMinusSrcAlpha</code> 以得到半透明效果。</li></ul><h2><span id="结构体定义">结构体定义</span></h2><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct a2v</span><br><span class="line">&#123;</span><br><span class="line">    float4 vertex : <span class="hljs-type">POSITION</span>;</span><br><span class="line">    float3 normal : <span class="hljs-type">NORMAL</span>;             </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct v2f</span><br><span class="line">&#123;</span><br><span class="line">    float4 pos : <span class="hljs-type">SV_POSITION</span>;</span><br><span class="line">    float3 normalDir : <span class="hljs-type">TEXCOORD0</span>;</span><br><span class="line">    float3 worldPos : <span class="hljs-type">TEXCOORD1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3><span id="a2v-包含顶点着色器要的模型数据">a2v ：包含顶点着色器要的模型数据</span></h3><ul><li><code>float4 vertex : POSITION;</code>这一句表示：用模型顶点的坐标填充vertex变量。 </li><li><code>float3 normal : NORMAL;</code> 这一句表示：用模型空间的法线方向向量填充normal变量</li></ul><h3><span id="v2f-用于顶点着色器和片元着色器之间传递信息">v2f ：用于顶点着色器和片元着色器之间传递信息</span></h3><ul><li><code>float4 pos : SV_POSITION;</code>这一句表示：用裁剪空间的位置信息填充pos变量</li><li><code>float3 normalDir : TEXCOORD0;</code>这一句表示：用模型的第一套纹理坐标填充normalDir变量</li><li><code>float3 worldPos : TEXCOORD1;</code>这一句表示：用模型的第二套纹理坐标填充worldPos变量</li></ul><h2><span id="顶点着色器">顶点着色器</span></h2><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">v2f vert( a2v v )</span><br><span class="line">&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.normalDir = UnityObjectToWorldNormal(v.normal); </span><br><span class="line">    o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">    <span class="hljs-keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>UnityObjectToClipPos(v.vertex)</code>是Unity5.6之后的写法，之前是<code>mul(UNITY_MATRIX_MVP,v.vertex)</code> 这一句的意思是:将模型空间的顶点信息转换到裁剪空间中的位置信息，然后将信息存储在o.pos中。</li><li><code>UnityObjectToWorldNormal(v.normal)</code>这一句的意思是:法线从模型空间变换到世界空间中并计算物体在世界空间中的法线坐标。</li><li><code>mul(unity_ObjectToWorld,v.vertex).xyz;</code>这一句的意思是：将顶点从模型空间转换到世界空间的信息存储到worldPos变量中。</li></ul><h2><span id="片元着色器">片元着色器</span></h2><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        fixed4 frag( v2f v ):<span class="hljs-type">COLOR</span></span><br><span class="line"><span class="hljs-type">        </span>&#123;</span><br><span class="line">            float3 normal = normalize(v.normalDir);</span><br><span class="line">            float3 viewDir = normalize(_WorldSpaceCameraPos - v.worldPos);</span><br><span class="line">            float normalDotViewDir = saturate(dot(normal,viewDir));</span><br><span class="line">fixed3 diffuse = normalDotViewDir *_Color;  </span><br><span class="line">            <span class="hljs-keyword">return</span> fixed4(diffuse + _RimColor ,(<span class="hljs-number">1</span> - normalDotViewDir) * (<span class="hljs-number">1</span> - _AlphaRange) + _AlphaRange);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li><code>fixed4 frag( v2f v ):COLOR</code>  我们注意到片元着色器的后面跟着<code>:COLOR</code> ：这是Unity提供的Cg/HLSL语义。语义可以告诉shader数据的来源以及数据的输出。</li><li><code>float3 viewDir = normalize(_WorldSpaceCameraPos - v.worldPos);</code> 这里我们用<code>对象在世界坐标系中的位置</code>减去<code>摄像机的世界空间位置</code>，并进行逐顶点归一化，赋给视线的方向</li><li><code>float normalDotViewDir = saturate(dot(normal,viewDir))</code> 我们获得法线与视线的夹角</li><li><code>fixed3 diffuse = normalDotViewDir *_Color;</code> 这里我们视线与法线的夹角和主颜色相乘。</li><li><code>return fixed4(diffuse + _RimColor ,(1 - normalDotViewDir) * (1 - _AlphaRange) + _AlphaRange);</code> 最后将混合后的颜色输出。</li></ul>]]></content>
>>>>>>> 5a816616ebf74eb2054f09a67ff9fdf655bff8bb
=======
        <content type="html"><![CDATA[<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>之前我们写过一个边缘发光的Shader（<a href="http://chenwenling.cn/2017/11/13/Unity%20Shader%20%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAShader/" target="_blank" rel="noopener">传送门</a>），这一次我们来写这个的升级版：透明物体的边缘发光。</p><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p>首先我们还是来看一下效果图：<br><img src="https://github.com/kurong00/blog/blob/master/thumbnail/shader5/RimEnerge.PNG?raw=true" alt></p><h2 id="Shader代码"><a href="#Shader代码" class="headerlink" title="Shader代码"></a>Shader代码</h2><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="hljs-string">"Custom/Rim/RimEnerge"</span> &#123;</span><br><span class="line">Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color(<span class="hljs-string">"Main Color"</span>,Color) = (<span class="hljs-number">0.6</span>,<span class="hljs-number">0.6</span>,<span class="hljs-number">0.6</span>,<span class="hljs-number">1</span>)</span><br><span class="line">        _AlphaRange(<span class="hljs-string">"Alpha Range"</span>,Range(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)) = <span class="hljs-number">0</span></span><br><span class="line">        _RimColor(<span class="hljs-string">"Rim Color"</span>,Color) = (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags&#123; </span><br><span class="line"><span class="hljs-string">"Queue"</span>=<span class="hljs-string">"Transparent"</span></span><br><span class="line"><span class="hljs-string">"IgnoreProjector"</span>=<span class="hljs-string">"True"</span></span><br><span class="line"><span class="hljs-string">"RenderType"</span>=<span class="hljs-string">"Transparent"</span> &#125;    </span><br><span class="line">ZWrite Off </span><br><span class="line">Blend SrcAlpha OneMinusSrcAlpha </span><br><span class="line">        LOD <span class="hljs-number">200</span>         </span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="hljs-meta">#pragma vertex vert</span></span><br><span class="line">            <span class="hljs-meta">#pragma fragment frag</span></span><br><span class="line"><span class="hljs-meta">#include "Lighting.cginc"      </span></span><br><span class="line"></span><br><span class="line">            struct a2v</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : <span class="hljs-type">POSITION</span>;</span><br><span class="line">                float3 normal : <span class="hljs-type">NORMAL</span>;             </span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float4 pos : <span class="hljs-type">SV_POSITION</span>;</span><br><span class="line">                float3 normalDir : <span class="hljs-type">TEXCOORD0</span>;</span><br><span class="line">                float3 worldPos : <span class="hljs-type">TEXCOORD1</span>;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            float _AlphaRange;</span><br><span class="line">            fixed4 _RimColor;</span><br><span class="line"></span><br><span class="line">            v2f vert( a2v v )</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex) ;</span><br><span class="line">                o.normalDir = UnityObjectToWorldNormal(v.normal); </span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">                <span class="hljs-keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag( v2f v ):<span class="hljs-type">COLOR</span></span><br><span class="line"><span class="hljs-type">            </span>&#123;</span><br><span class="line">                float3 normal = normalize(v.normalDir);</span><br><span class="line">                float3 viewDir = normalize(_WorldSpaceCameraPos - v.worldPos);</span><br><span class="line">                float normalDotViewDir = saturate(dot(normal,viewDir));</span><br><span class="line">fixed3 diffuse = normalDotViewDir *_Color;  </span><br><span class="line">                <span class="hljs-keyword">return</span> fixed4(diffuse + _RimColor ,(<span class="hljs-number">1</span> - normalDotViewDir) * (<span class="hljs-number">1</span> - _AlphaRange) + _AlphaRange);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback <span class="hljs-string">"Diffuse"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="透明度混合"><a href="#透明度混合" class="headerlink" title="透明度混合"></a>透明度混合</h2><p>上一篇我们了解了透明度混合的原理以及一些透明度知识（<a href="http://chenwenling.cn/2017/11/18/Unity%20Shader%20%E5%85%A5%E9%97%A8%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/" target="_blank" rel="noopener">传送门</a>），而Unity中，为了进行透明度混合，我们需要用到【Blend】命令： </p><table><thead><tr><th style="text-align:center">语法</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">Blend Off</td><td style="text-align:center">关闭混合（这是默认的状态）</td></tr><tr><td style="text-align:center">Blend SrcFactor DstFactor</td><td style="text-align:center">开启混合，该片元产生的颜色<em>SrcFactor. 已存在于屏幕的颜色 </em>DstFactor，然后将两者叠加在一起存入颜色缓冲。</td></tr><tr><td style="text-align:center">Blend SrcFactor DstFactor, SrcFactorA DstFactorA</td><td style="text-align:center">原理同上，不过使用了不同的混合因子</td></tr><tr><td style="text-align:center">BlendOp Op</td><td style="text-align:center">不同于上面的颜色混合，而是使用Blend Operation（<a href="https://docs.unity3d.com/Manual/SL-Blend.html" target="_blank" rel="noopener">传送门</a>）来对它们进行操作</td></tr><tr><td style="text-align:center">BlendOp OpColor, OpAlpha</td><td style="text-align:center">原理同上，不过采用不同的Blend Operation来操作Color和Alpha的通道</td></tr></tbody></table><p>混合因子：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">One</td><td style="text-align:center">因子为1，表示让源颜色或者目标颜色通过</td></tr><tr><td style="text-align:center">Zero</td><td style="text-align:center">因子为0，用来删除源颜色或者目标颜色</td></tr><tr><td style="text-align:center">SrcColor</td><td style="text-align:center">因子为源颜色</td></tr><tr><td style="text-align:center">SrcAlpha</td><td style="text-align:center">因子为源颜色的透明度</td></tr><tr><td style="text-align:center">DstColor</td><td style="text-align:center">因子为目标颜色</td></tr><tr><td style="text-align:center">DstAlpha</td><td style="text-align:center">因子为目标颜色的透明度</td></tr><tr><td style="text-align:center">OneMinusSrcColor</td><td style="text-align:center">因子为 (1 - 源颜色) 的值</td></tr><tr><td style="text-align:center">OneMinusSrcAlpha</td><td style="text-align:center">因子为 (1 - 源颜色的透明度) 的值</td></tr><tr><td style="text-align:center">OneMinusDstColor</td><td style="text-align:center">因子为 (1 - 目标颜色) 的值</td></tr><tr><td style="text-align:center">OneMinusDstAlpha</td><td style="text-align:center">因子为 (1 - 目标颜色的透明度) 的值</td></tr></tbody></table><p>此时我们再来看上面这一块代码：<br><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Tags&#123; </span><br><span class="line"><span class="hljs-string">"Queue"</span>=<span class="hljs-string">"Transparent"</span></span><br><span class="line"><span class="hljs-string">"IgnoreProjector"</span>=<span class="hljs-string">"True"</span></span><br><span class="line"><span class="hljs-string">"RenderType"</span>=<span class="hljs-string">"Transparent"</span> &#125;    </span><br><span class="line">ZWrite Off </span><br><span class="line">Blend SrcAlpha OneMinusSrcAlpha </span><br><span class="line">        LOD <span class="hljs-number">200</span></span><br></pre></td></tr></table></figure></p><ul><li><p>这里有一些新的知识：之前提过半透明物体的渲染序列要设置成<code>&quot;Queue&quot;=&quot;Transparent&quot;</code>,而<code>&quot;RenderType&quot;=&quot;Transparent&quot;</code>表示我们使用了透明度混合。通常一个半透明的Shader Tags都包含这三条：</p><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-string">"Queue"</span>=<span class="hljs-string">"Transparent"</span></span><br><span class="line"><span class="hljs-string">"IgnoreProjector"</span>=<span class="hljs-string">"True"</span></span><br><span class="line"><span class="hljs-string">"RenderType"</span>=<span class="hljs-string">"Transparent"</span></span><br></pre></td></tr></table></figure></li><li><p>接下来是  <code>ZWrite Off</code> : 我们在上一篇介绍过为什么透明度混合需要关闭深度写入</p></li><li>最后是  <code>Blend SrcAlpha OneMinusSrcAlpha</code> : 这里我们将源颜色的混合因子设置成<code>SrcAlpha</code>，将目标颜色的混合因子设置成 <code>OneMinusSrcAlpha</code> 以得到半透明效果。</li></ul><h2 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h2><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct a2v</span><br><span class="line">&#123;</span><br><span class="line">    float4 vertex : <span class="hljs-type">POSITION</span>;</span><br><span class="line">    float3 normal : <span class="hljs-type">NORMAL</span>;             </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct v2f</span><br><span class="line">&#123;</span><br><span class="line">    float4 pos : <span class="hljs-type">SV_POSITION</span>;</span><br><span class="line">    float3 normalDir : <span class="hljs-type">TEXCOORD0</span>;</span><br><span class="line">    float3 worldPos : <span class="hljs-type">TEXCOORD1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="a2v-：包含顶点着色器要的模型数据"><a href="#a2v-：包含顶点着色器要的模型数据" class="headerlink" title="a2v ：包含顶点着色器要的模型数据"></a>a2v ：包含顶点着色器要的模型数据</h3><ul><li><code>float4 vertex : POSITION;</code>这一句表示：用模型顶点的坐标填充vertex变量。 </li><li><code>float3 normal : NORMAL;</code> 这一句表示：用模型空间的法线方向向量填充normal变量</li></ul><h3 id="v2f-：用于顶点着色器和片元着色器之间传递信息"><a href="#v2f-：用于顶点着色器和片元着色器之间传递信息" class="headerlink" title="v2f ：用于顶点着色器和片元着色器之间传递信息"></a>v2f ：用于顶点着色器和片元着色器之间传递信息</h3><ul><li><code>float4 pos : SV_POSITION;</code>这一句表示：用裁剪空间的位置信息填充pos变量</li><li><code>float3 normalDir : TEXCOORD0;</code>这一句表示：用模型的第一套纹理坐标填充normalDir变量</li><li><code>float3 worldPos : TEXCOORD1;</code>这一句表示：用模型的第二套纹理坐标填充worldPos变量</li></ul><h2 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h2><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">v2f vert( a2v v )</span><br><span class="line">&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.normalDir = UnityObjectToWorldNormal(v.normal); </span><br><span class="line">    o.worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;</span><br><span class="line">    <span class="hljs-keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>UnityObjectToClipPos(v.vertex)</code>是Unity5.6之后的写法，之前是<code>mul(UNITY_MATRIX_MVP,v.vertex)</code> 这一句的意思是:将模型空间的顶点信息转换到裁剪空间中的位置信息，然后将信息存储在o.pos中。</li><li><code>UnityObjectToWorldNormal(v.normal)</code>这一句的意思是:法线从模型空间变换到世界空间中并计算物体在世界空间中的法线坐标。</li><li><code>mul(unity_ObjectToWorld,v.vertex).xyz;</code>这一句的意思是：将顶点从模型空间转换到世界空间的信息存储到worldPos变量中。</li></ul><h2 id="片元着色器"><a href="#片元着色器" class="headerlink" title="片元着色器"></a>片元着色器</h2><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        fixed4 frag( v2f v ):<span class="hljs-type">COLOR</span></span><br><span class="line"><span class="hljs-type">        </span>&#123;</span><br><span class="line">            float3 normal = normalize(v.normalDir);</span><br><span class="line">            float3 viewDir = normalize(_WorldSpaceCameraPos - v.worldPos);</span><br><span class="line">            float normalDotViewDir = saturate(dot(normal,viewDir));</span><br><span class="line">fixed3 diffuse = normalDotViewDir *_Color;  </span><br><span class="line">            <span class="hljs-keyword">return</span> fixed4(diffuse + _RimColor ,(<span class="hljs-number">1</span> - normalDotViewDir) * (<span class="hljs-number">1</span> - _AlphaRange) + _AlphaRange);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li><code>fixed4 frag( v2f v ):COLOR</code>  我们注意到片元着色器的后面跟着<code>:COLOR</code> ：这是Unity提供的Cg/HLSL语义。语义可以告诉shader数据的来源以及数据的输出。</li><li><code>float3 viewDir = normalize(_WorldSpaceCameraPos - v.worldPos);</code> 这里我们用<code>对象在世界坐标系中的位置</code>减去<code>摄像机的世界空间位置</code>，并进行逐顶点归一化，赋给视线的方向</li><li><code>float normalDotViewDir = saturate(dot(normal,viewDir))</code> 我们获得法线与视线的夹角</li><li><code>fixed3 diffuse = normalDotViewDir *_Color;</code> 这里我们视线与法线的夹角和主颜色相乘。</li><li><code>return fixed4(diffuse + _RimColor ,(1 - normalDotViewDir) * (1 - _AlphaRange) + _AlphaRange);</code> 最后将混合后的颜色输出。</li></ul>]]></content>
>>>>>>> 4024136f960a92478bab432f0a5f382e14512e93
      
      
      <categories>
          
          <category> Shader </category>
          
      </categories>
      
      
    </entry>
    
<<<<<<< HEAD
=======
    
    
>>>>>>> 9e62def5d865150fae5440cc55e3c06c4faf11a3
    <entry>
      <title>Unity Shader 入门（四）：透明效果知识储备</title>
      <link href="/2017/11/18/Unity%20Shader%20%E5%85%A5%E9%97%A8%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/"/>
      <url>/2017/11/18/Unity%20Shader%20%E5%85%A5%E9%97%A8%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>首先一个问题：如果场景中有非常多的物体，彼此之间有互相遮挡的情况，那么这些物体是按照什么样的渲染顺序进行渲染的呢？</p><h3 id="深度缓冲"><a href="#深度缓冲" class="headerlink" title="深度缓冲"></a>深度缓冲</h3><p>实际上，由于深度缓存（z-buffer）的存在,不透明的物体在不考虑渲染顺序的情况下也可以正确的被渲染。深度缓冲是用来解决物体可见性的问题，基本思想是：根据深度缓存里的值判断这个物体距离摄像机的距离。开始渲染一个片元的时候，需要把它的深度值和已存在于深度缓存中的值作比较，如果它的值距离摄像机更远那么就不会被渲染到屏幕上。否则更新片元的深度值到深度缓存中。</p><h2 id="透明效果"><a href="#透明效果" class="headerlink" title="透明效果"></a>透明效果</h2><p>我们可以不关心不透明物体的渲染顺序，因为在深度测试中就可以测试出物体离摄像机的距离再判断是否写入颜色缓冲。但是对于不透明物体，就没这么简单了。想要达到半透明的效果，我们要利用透明度混合。</p><h3 id="透明度混合"><a href="#透明度混合" class="headerlink" title="透明度混合"></a>透明度混合</h3><p>透明度混合要关闭深度写入。这是因为：假如一个半透明物体在一个不透明物体的前面，如果开启深度写入的话，距离摄像机更远的不透明物体就会被剔除，但是依照常理我们是可以透过半透明的物体看到不透明的物体。但是这就破坏了深度缓冲的机制，这是非常不好但是不得不做的折中方法，也因此使得渲染顺序变得非常重要。（注意：关闭深度写入，但是没有关闭深度测试）</p><h3 id="渲染顺序"><a href="#渲染顺序" class="headerlink" title="渲染顺序"></a>渲染顺序</h3><p>我们考虑两种情况：</p><ol><li>既有半透明物体也有不透明物体：我们先渲染所有的不透明物体再渲染半透明物体</li><li>全是半透明物体：开启深度测试，关闭深度写入的情况下将半透明物体按照距离摄像机的远近从后往前渲染。<ul><li>这里有一个小问题，深度缓冲中的值是像素级别的，而一个半透明物体很可能有非常多个像素，这么一来每一个像素的深度值都可能不一样，以此会产生<font color="#D37885"> 循环遮挡</font>的情况。</li><li>为了规避上面的问题，常常会把大的模型分割成小的几块，这样即使出现渲染错误，也不会出现太出格的结果。</li></ul></li></ol><h3 id="Unity设置的渲染序列"><a href="#Unity设置的渲染序列" class="headerlink" title="Unity设置的渲染序列"></a>Unity设置的渲染序列</h3><p>类似之前<code>Tags { &quot;RenderType&quot;=&quot;Opaque&quot; }</code>,我们可以用Queue标签来决定我们的模型是怎么渲染的。</p><table><thead><tr><th style="text-align:center">队列名称</th><th style="text-align:center">队列索引</th><th style="text-align:center">索引描述</th></tr></thead><tbody><tr><td style="text-align:center">Background</td><td style="text-align:center">1000</td><td style="text-align:center">最早被渲染的队列，一般绘制背景元素</td></tr><tr><td style="text-align:center">Geometry</td><td style="text-align:center">2000</td><td style="text-align:center">默认渲染队列，不透明物体渲染队列</td></tr><tr><td style="text-align:center">AlphaTest</td><td style="text-align:center">2450</td><td style="text-align:center">需要透明度测试的物体在这个队列渲染</td></tr><tr><td style="text-align:center">Transparent</td><td style="text-align:center">3000</td><td style="text-align:center">使用透明度混合的物体在这个队列渲染</td></tr><tr><td style="text-align:center">Overlay</td><td style="text-align:center">4000</td><td style="text-align:center">最后被渲染的物体在这个队列，一般用于叠加效果</td></tr></tbody></table><h3 id="代码设置"><a href="#代码设置" class="headerlink" title="代码设置"></a>代码设置</h3><p>如果我们想要通过透明度混合来实现半透明效果，代码如下<br><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SubShader</span><br><span class="line">   &#123;</span><br><span class="line">       Tags &#123; <span class="hljs-string">"RenderType"</span>=<span class="hljs-string">"Transparent"</span> &#125;  </span><br><span class="line">       Pass &#123; </span><br><span class="line">    ZWrite Off ······</span><br><span class="line">       &#125; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>ZWrite Off 意味者关闭深度写入，或者可以：<br><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SubShader</span><br><span class="line">   &#123;</span><br><span class="line">       Tags &#123; <span class="hljs-string">"RenderType"</span>=<span class="hljs-string">"Transparent"</span> &#125;  </span><br><span class="line">       ZWrite Off ······</span><br><span class="line">       Pass &#123; &#125; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>这样表示这个SubShader下的所有Pass都会关闭深度写入</p>]]></content>
      
      
      <categories>
          
          <category> Shader </category>
          
      </categories>
      
      
    </entry>
    
<<<<<<< HEAD
=======
    
    
      
</search>
